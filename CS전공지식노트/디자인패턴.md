## 디자인 패턴

디자인패턴이란? 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관게 등을 이용하여 해결할 수 있도록 하나의 **‘규약’** 형태로 만들어 놓은 것을 의미.

## 싱글톤패턴

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴. 보통 데이터 베이스 연결 모듈에 많이 사용한다. 하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스를 생성할 때 드는 비용이 줄어드는 장점이 있다. 하지만 의존성이 높아진다는 단점이 있다.

```jsx
const URL = 'mongo';
const createConnection = (url) => ({ url: url });
class DB {
  constructor(url) {
    if (!DB) {
      DB.instance = createConnection(url);
    }

    return DB.instance;
  }

  connect() {
    return this.instance;
  }
}

const a = new DB(url);
const b = new DB(url);
```

## 싱글톤 패턴의 단점

TDD를 할 때 걸림돌이 된다. 단위 테스트는 테스트가 서로 독립적이어야 하며, 테스트를 어떤 순서로든 실행할 수 있어야 한다. 하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 ‘독립적인’ 인스턴스를 만들기가 어렵다

## 의존성 주입

또한, 싱글톤 패턴은 모듈 간의 결합을 강하게 만들 수 있다는 단점이 있다. 이때 의존성 주입을 통해 모듈간의 결합을 조금 더 느슨하게 만들어 해결할 수 있다.

의존성 : 종속성이라고도 하며 A가 B에 의존성이 있다는 것은 B의 변경사항에 대해 A또한 변해야 된다는 것을 의미

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/0f1a2bc5-0569-403f-82a9-884def314825/image.png)

앞의 그림처럼 메인 모듈이 직접 다른 하위 모듈에 대한 의존성을 주기 보다는,

중간에 의존성 주입자가 이 부분을 가로채 메인 모듈이 간접적으로 의존성을 주입하는 방식.

**의존성 주입의 장점**

모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅하기 쉽고 마이그레이션도 수월하다.

**단점**

모듈이 더욱 분리되므로 클래수 수가 늘어나 복잡성이 증가될 수 있으며 약간의 런타임 패널티가 생기기도 한다.

**주입 원칙**

“상위 모듈은 하위 모듈에서 어떤 것도 가져오지 않아야 한다.”

“둘다 추상화에 의존해야 한다.”

“이때 추상화는 세부 사항에 의존하지 말아야 한다.”

# 팩토리 패턴

객체를 사용하는 코드에서 객체 생성 부분을 뗴어내 추상화한 패턴

상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴

상위 클래스/하위 클래스가 분리되기 때문에 느슨한 결합을 가짐.

CoffeFactory 라는 상위 클래스가 중요한 뼈대를 결정.

하위 클래스인 LatteFactory가 구체적인 내용을 결정.

[ 키워드 : 느슨한 결합, 유연성 ]

# 전략 패턴

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/1aac565d-d8ca-459f-bbe3-2ef8e25c3370/image.png)

객체의 행위를 바꾸고 싶은 경우 ‘직접’ 수정하지 않고 전략이라고 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

### Passport의 전략패턴

```jsx
var passport = require('passport'),
  LocalStrategy = require('passport-local').Strategy;

passport.use(
  new LocalStrategy(function (username, password, done) {
    User.findOne({ username: username }, function (err, user) {
      if (err) {
        return done(err);
      }
      if (!user) {
        return done(null, false, { message: 'Incorrect username.' });
      }
      if (!user.validPassword(password)) {
        return done(null, false, { message: 'Incorrect password.' });
      }
      return done(null, user);
    });
  })
);
```

결론적으로, `passport.use`에 넣은 것이 전략인 이유는

그 부분이 `"인증을 수행하는 방법"`을 정의하는 코드이기 때문.

# 옵저버 패턴

어떤 객체의 상태 변화를 관찰하다 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴

옵저버 패턴은 주로 이벤트 기반 시스템에 사용하며 MVC패턴에도 사용된다.

예를 들어 주체라고 볼 수 있는 모델에서 변경사항이 생겨 update() 메서드로 옵저버인 뷰에 알려주고 이를 기반으로 컨트롤러를 작동 시키는 것.

# [Proxy](https://ko.javascript.info/proxy#ref-1205)

문법:

`let proxy = new Proxy(target, handler)`

- `target` – 감싸게 될 객체로, 함수를 포함한 모든 객체가 가능
- `handler` – 동작을 가로채는 메서드인 '트랩(trap)'이 담긴 객체로, 여기서 프락시를 설정(예시: `get` 트랩은 `target`의 프로퍼티를 읽을 때, `set` 트랩은 `target`의 프로퍼티를 쓸 때 활성화됨)
-

어떠한 대상의 기본적인 동작(속성 접근,할당,순회,열거,함수 호출 등)의 작업을 가로챌 수 있는 객체를 뜻하며 자바스크립트에서 프록시 객체는 두 개의 매개변수를 가진다.

**target**: 프록시할 대상

**handler**: targer동작을 가로채고 어떠한 동작을 할것인지가 설정되어있는 함수

# 프록시 패턴

대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층이 있는 디자인 패턴

**버퍼 오버플로우:** 버퍼는 보통 데이터가 저장되는 메모리 공간으로 메모리 공간으로 메모리 공간을 벗어나는 경우를 말한다. 이때 사용되지 않아야 할 영역에 데이터가 덮어 씌워져 주소, 값을 바꾸는 공격이 발생하기도 한다.

[Proxy와 Reflect](https://ko.javascript.info/proxy)

# 노드서버를 구축할때 엔진엑스를 앞단에 둔다는게 뭔말?

**Nginx(Nginx)** 웹 서버를 Node.js 서버 앞에 두어 **리버스 프록시**(Reverse Proxy) 역할을 하게 한다는 의미입니다. 이를 통해 Node.js 서버로 들어오는 요청을 효율적으로 처리하고 관리할 수 있습니다.

### **리버스 프록시란?**

리버스 프록시는 클라이언트가 요청을 보내면, 이 요청을 받아서 실제 서버(Node.js 서버)로 전달하고, 서버에서 받은 응답을 다시 클라이언트에게 전달하는 중간 서버 역할을 한다.

### **실제 동작 예시**

1. **클라이언트**가 브라우저에서 `www.example.com`에 접속
2. 이 요청은 먼저 **Nginx** 서버로 도달
3. Nginx는 이 요청을 보고, 이를 **Node.js** 서버로 전달 (리버스 프록시).
4. Node.js 서버는 요청을 처리하고 응답을 Nginx에 반환
5. Nginx는 이 응답을 받아 **클라이언트**에게 다시 전달

```jsx
Client (사용자)  -->  Nginx (리버스 프록시)  -->  Node.js 서버
```

# 이터레이터 패턴

이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴

이를 통해 순회할 수 이는 여러 가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회가 가능

# 노출모듈 패턴

즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴.

# MVC패턴

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/77ec1483-f7af-47fa-b9e4-c43902b13132/image.png)

## 모델

- 어플리케이션 데이터인 DB, 상수, 변수 등

뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신

## 뷰

- 사용자 인터페이스 요소
- 모델을 기반으로 사용자가 볼 수 있는 화면
- 변경이 일어나면 컨트롤러에 이를 전달

## 컨트롤러

- 모델과 뷰를 잇는 다리 역할
- 이벤트 등 메인 로직 담당
- 모델, 뷰의 생명 주기 관리

# 설계 원칙

## 단일책임 원칙

모든 클래스는 각각 하나의 책임을 가진다.

## 개방-폐쇄 원칙

유지 보수 사항이 생긴다면 코드를 쉽게 확장 할 수 있도록 한다.

수정할 때는 닫혀 있어야 한다.

## 리스코프 치환 원칙

정확성을 꺠뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

## 인터페이스 분리 원칙

하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야한다.

## 의존 역전

자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향 받지 않게 한다. 즉, 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 한다.
