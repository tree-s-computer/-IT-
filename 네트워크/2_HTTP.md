## HTTP 요청 응답 모델

HTTP 요청-응답 모델은 클라이언트와 서버 간의 통신 방식으로, 클라이언트가 요청(Request)을 보내고 서버가 이에 대한 응답(Response)을 반환하는 형태로 작동합니다. 이 모델은 웹의 기본적인 작동 원리로, 웹 브라우저와 웹 서버 간의 상호작용을 이해하는 데 필수적입니다.

## HTTP 의 무상태성

무상태 프로토콜이란 서버가 클라이언트의 상태를 보존하지 않는 특징입니다. 서버의 확장성에 용이하다는 장점이 있지만, 클라이언트가 추가 데이터를 전송해야 하는 단점이 있습니다.

**[ 키워드 : 상태 보존X, 서버 확장성 ]**

### 꼬리질문: 왜 서버 확장성에 용이하다고 생각하시나요 ?

- 무상태 프로토콜에서는 각 요청이 `독립적`으로 처리됩니다. 클라이언트의 상태 정보(예: 로그인 세션, 장바구니 상태 등)를 서버가 유지하지 않기 때문에, 어떤 서버든 `클라이언트 요청을 동일하게 처리`할 수 있습니다.
- 만약 세션 상태를 서버가 유지한다면, 클라이언트의 다음 요청은 반드시 그 상태를 가지고 있는 서버로 가야 합니다. 이를 위해 서버 간에 상태 정보를 공유하거나 특정 서버로의 라우팅을 보장해야 합니다. 이는 복잡성을 증가시키고, **서버를 쉽게 추가하거나 교체하기 어렵게 만듭니다.**

## PUT PATCH

PATCH도 수정을 담당하는 메서드라는데, PUT도 수정에 사용되는 거라고 합니다. 그렇다면 이 둘은 어떻게 다른 것일까요? *PATCH는 수정만 담당하며 리소스의 `일부분만 수정`*할 때 사용하고, *PUT은 리소스의 `모든 속성`을 수정*하기 위해 사용합니다.

## Keep-Alive

HTTP의 **Keep-Alive**는 클라이언트와 서버 간의 연결을 `지속적으로 유지`하는 기능을 말합니다. 기본적으로 HTTP/1.0에서는 각 요청-응답 사이클이 끝날 때마다 TCP 연결이 닫힙니다. 하지만 Keep-Alive 기능을 사용하면, 여러 개의 요청-응답을 동일한 TCP 연결에서 처리할 수 있습니다.

HTTP는 TCP 연결 기반 위에서 동작하는 프로토콜로 신뢰성 확보를 위해 연결을 맺고 끊는 데 있어서 3way HandshakeVisit Website 가 이루어집니다. 그런데 HTTP는 기본적으로 `비연결성(connecitonless)` 프로토콜이기 때문에 한 번의 요청과 응답을 하고 응답이 끝나면 연결을 끊어 버리는데, 자원을 요청할때 마다 연결을 맺고 끊어버려오버헤드(overhead)Visit Website가 생기게 됩니다. `그래서 HTTP/1.1에서Persistent Connection 기능이 추가`됨으로써, 한 번 맺어졌던 연결을 끊지 않고 지속적으로 유지하여 불필요한 Handshake를 줄여 성능을 개선하였습니다.

비연결성 특징 때문에 **지속 연결(Keep-Alive)** 기능이 추가된 것입니다. 이 두 개념은 `상호 보완`적입니다.

HTTP/1.1에서는 `기본적으로 Keep-Alive가 활성화`되어 있으며, 클라이언트와 서버 간의 연결을 유지하여 여러 요청을 동일한 TCP 연결에서 처리할 수 있게 합니다. 이렇게 하면 반복적인 연결 설정/해제 과정이 줄어들고, 성능이 개선되며, 네트워크 리소스가 더 효율적으로 사용됩니다.

**[ 키워드 : 지속적 유지,기본적 비연결성,상호보완,불필요한 HandShake 감소]**

### 꼬리질문: keep-alive 기능을 사용하는 이유?

- 매 request 마다 새로운 connection을 맺을 필요가 없기 때문에 3-Way handshake를 하지 않아 해당 작업을 하면서 생기는 round-trip을 줄이기 때문에 latency 를 감소시킬 수 있습니다.
- 많은 양의 connection을 맺고 끊음으로서 발생할 수 있는 네트워크 혼잡 상황을 방지할 수 있습니다.

하지만 keep-alive 로 인해 발생되는 **문제도 존재합니다**. client 가 의도적으로든 아니든 지속적으로 `connection을 점유`하고 있기 때문에 server 단에서 connection을 맺을 socket이 부족해지는 문제가 발생할 수도 있습니다. 이에 따른 처리 방식을 server에서 충분히 해주어야 문제를 줄일 수 있습니다.

- **Round-Trip Time (RTT)**: 클라이언트가 서버로 요청을 보내고, 그 요청에 대한 응답이 다시 클라이언트로 돌아오기까지 걸리는 시간을 의미합니다.
- 예를 들어, 웹 브라우저에서 사용자가 페이지를 요청할 때, 그 요청이 서버로 전송되고, 서버가 응답을 준비하여 다시 브라우저로 보낼 때까지의 시간을 "왕복 시간"이라고 합니다.

- **Latency**는 네트워크에서 데이터가 목적지에 도달하기까지 걸리는 시간을 말합니다. 이는 RTT의 일부로, 클라이언트에서 서버로 데이터가 가는 시간과 서버에서 클라이언트로 돌아오는 시간으로 나눌 수 있습니다.
- **지연 시간**은 여러 요인에 의해 영향을 받을 수 있습니다. 예를 들어, 물리적인 거리(서버가 멀리 있을수록 지연 시간이 길어짐), 네트워크 혼잡, 장비 성능 등이 이에 해당합니다.

### **소켓(socket)**

- **소켓**은 클라이언트와 서버 간의 네트워크 통신을 가능하게 하는 `기초적인 연결 단위`입니다. 클라이언트가 서버에 요청을 보내고, 서버가 이에 응답하는 과정에서 소켓이 사용됩니다.
- 서버는 클라이언트로부터의 연결 요청을 받을 때마다 새로운 소켓을 생성해 이 연결을 처리합니다.

### **소켓 부족 현상**

- 서버에는 **최대 동시 연결 수**라는 제한이 있습니다. 이는 서버가 동시에 처리할 수 있는 소켓의 수를 의미합니다.
- 만약 keep-alive 기능으로 인해 클라이언트가 연결을 계속 유지하고 있으면, 그 동안 다른 클라이언트가 접속하려 할 때 사용할 수 있는 소켓의 수가 줄어들게 됩니다.
- 일정한 한도를 넘어서면 더 이상 새로운 연결을 수용할 수 없게 되어, 신규 요청이 거부되거나 대기해야 하는 상황이 발생할 수 있습니다. 이를 **소켓 부족 현상**이라 부릅니다.

### **프론트엔드 관점에서의 이해**

- 프론트엔드 개발자 입장에서 보면, keep-alive를 통해 페이지 로딩 속도가 개선될 수 있습니다. 이는 네트워크 지연이 줄어들고 연결 재사용 덕분에 서버와의 통신이 더 효율적으로 이루어지기 때문입니다.
- 하지만 서버 자원이 제한된 경우, 많은 사용자가 접속할 때 서버가 연결을 처리하지 못해 응답이 느려지거나 요청이 실패할 수 있습니다. 이러한 경우 페이지가 로드되지 않거나, 서버와의 통신이 중단되는 문제가 발생할 수 있습니다.

## 파이프라이닝

파이프 라이닝은 여러개의 요청을 보낼때 처음 요청이 응답될 때까지 기다리지 않고 바로요청을 한꺼번에 보내는 것을 의미합니다. 즉, **여러개의 요청을 한꺼번에 보내서 응답을 받음**으로서 대기시간을 줄이는 기술입니다. 다만 파이프 라이닝은 어찌보면 정말 혁신적인 기술이지만, 보낸 요청 순서대로 응답을 받아야하는 규칙 부분에서 문제가 생기게 됩니다.

마치 FIFO(선입선출) 처럼 생각하면 되는데, 문제는 요청하는 데이터의 크기는 제각각 이기 때문에, 첫번째로 요청한 데이터가 용량이 큰 데이터라면, 두번째, 세번째 데이터가 아무리 빨리 처리되어도 우선순위 원칙에 따라 첫번째 데이터의 응답 속도가 늦어지면 후 순위에 있는 데이터 응답속도도 덩달아 늦어지게 되는 것입니다.

# DNS 예상질문

## DNS란?

DNS(Domain Name System)는 인터넷에서 사용되는 네트워크 서비스로, 사람이 이해하기 쉬운 도메인 이름(예: www.example.com)과 컴퓨터가 이해하는 IP 주소(예: 192.0.2.1)를 매핑하는 시스템입니다. DNS는 사용자가 도메인 이름을 입력하면 해당 도메인 이름에 대응하는 IP 주소를 찾아주는 역할을 합니다.

인터넷에서 컴퓨터나 네트워크 기기들은 IP 주소를 사용하여 서로 통신합니다. 하지만 IP 주소는 일련의 숫자로 이루어져 있어서 사람이 기억하고 입력하기 어렵습니다. 따라서 사람들은 도메인 이름을 사용하여 웹 사이트에 접속하거나 이메일을 보내는 등의 활동을 합니다.

`DNS는 이러한 도메인 이름과 IP 주소 사이의 매핑을 제공`하여, 사용자가 도메인 이름을 입력하면 해당 도메인 이름에 대응하는 IP 주소를 찾아주는 역할을 수행합니다. DNS 서버들이 전 세계적으로 분산되어 있으며, 도메인 이름과 IP 주소의 매핑 정보를 저장하고 관리합니다.

도메인: 문자열의 탈을 쓴 IP

**[ 키워드 : 매핑 시스템 ]**

## DNS 작동 방식

1. 사용자가 도메인 이름을 입력합니다.
   - 예를 들어, 사용자가 웹 브라우저에 "www.example.com"과 같은 도메인 이름을 입력합니다.
2. 브라우저 캐시, OS 캐시, 라우터 캐시 확인
3. 로컬 DNS 캐시 확인
   - 웹 브라우저는 로컬 DNS 클라이언트 역할을 수행하여, **먼저 로컬 DNS 캐시를 확인**합니다.로컬 DNS 캐시에는 최근에 이용한 도메인 이름과 해당 도메인 이름에 대응하는 IP 주소 정보가 저장되어 있습니다.이전에 동일한 도메인 이름에 접속했던 기록이 있다면 로컬 DNS 캐시에서 바로 해당 IP 주소를 찾을 수 있습니다.
4. **로컬 네트워크의 DNS 서버 질의:**
   - **로컬 DNS 캐시에 해당 정보가 없는 경우, 웹 브라우저는 로컬 네트워크에 설정된 DNS 서버로 질의(Query)를 보냅니다. 로컬 네트워크의 DNS 서버는 도메인 이름에 대응하는 IP 주소 정보를 가지고 있는지 확인하기 위해 다른 DNS 서버들과 질의를 주고받습니다.**
5. **루트 DNS 서버 질의:**
   - **로컬 네트워크의 DNS 서버도 해당 정보가 없는 경우, 루트 DNS 서버에 질의를 보내게 됩니다.루트 DNS 서버는 인터넷의 최상위 도메인(.com, .org 등)의 DNS 서버 주소를 알려줍니다.**
6. **중간 DNS 서버 질의:**
   - **로컬 네트워크의 DNS 서버는 루트 DNS 서버로부터 얻은 최상위 도메인(.com, .org 등)의 DNS 서버에 다시 질의를 보냅니다.이 과정이 계층적으로 반복되며, 최종적으로 해당 도메인 이름에 대응하는 IP 주소를 찾습니다.**
7. IP 주소 반환:
   - DNS 서버들은 계층적으로 도메인 이름을 분석하여 **`최종적으로 해당 도메인 이름에 대응하는 IP 주소를 찾아 반환`**합니다.
8. 웹 브라우저 요청:
   - 웹 브라우저는 받은 IP 주소를 사용하여 해당 웹 서버에 요청을 보내고 웹 페이지를 받아옵니다.이후, 해당 도메인 이름과 IP 주소의 매핑 정보는 로컬 DNS 캐시에 저장되어 다음에 동일한 도메인에 접속할 때 빠르게 IP 주소를 찾을 수 있도록 합니다.

## DNS 질의 종류에 대해 설명해주세요.

DNS(Domain Name System)에서는 다양한 질의 종류가 있으며, 각각의 질의 종류에 따라 다른 정보를 얻을 수 있습니다. 일반적으로 가장 많이 사용되는 네 가지 주요 질의 종류는 다음과 같습니다:

- `A 질의` (Address Record Query):
  A 질의는 도메인 이름에 대응하는 IPv4 주소를 찾기 위해 사용됩니다.
  예를 들어, "www.example.com"에 대한 A 질의를 하면 해당 도메인 이름에 대응하는 IPv4 주소를 반환합니다.
- `AAAA 질의` (IPv6 Address Record Query):
  AAAA 질의는 도메인 이름에 대응하는 IPv6 주소를 찾기 위해 사용됩니다.
  IPv6는 IPv4보다 더 긴 주소 체계를 사용하므로, AAAA 질의를 통해 IPv6 주소를 얻을 수 있습니다.
- `CNAME 질의` (Canonical Name Record Query):
  CNAME 질의는 도메인 이름에 대해 다른 도메인 이름(CNAME)을 찾기 위해 사용됩니다.
  CNAME은 도메인 이름을 다른 도메인 이름으로 매핑하는데 사용되며, 도메인 이름의 별칭을 설정하는 데 유용합니다.
- `MX 질의` (Mail Exchanger Record Query):
  MX 질의는 도메인 이름에 대응하는 메일 서버의 정보를 찾기 위해 사용됩니다.
  이 정보를 사용하여 해당 도메인 이름으로 이메일을 보낼 때 메일이 전달될 서버를 확인할 수 있습니다.
  ## DNS 서버에게 IP 주소를 요청할 때, 왜 UDP를 사용하나요?
  TCP 와 UDP는 **신뢰성 vs 신속성** 의 특징을 놓고 tcp와 udp를 이용하는 서비스 들이 갈립니다.
  TCP는 - HTTP, Email, FIle transfer
  UDP는 - DNS, Broadcasting
  UDP는 트랜스포트 계층 프로토콜이 할 수 있는 **최소 기능**으로 동작합니다. 즉, 다중화/역다중화 기능과 간단한 오류 검사 기능을 제외하면 IP에 아무것도 추가하지 않습니다. 그래서 애플리케이션 개발자가 TCP대신에 UDP를 선택한다면 애플리케이션은 거의 IP와 직접 통신하는 것입니다.
  > tcp에 비해 다음과 같은 특징을 갖고 있기에 DNS 서비스가 사용하기 적합합니다.
  - 연결의 시작 과 끝 설정이 없다는 점, 만약 dns가 tcp위에서 동작한다면 많이 느려질 것입니다. 반면 http문서로 된 웹페이지는 신뢰성이 중요하기 때문에 udp보다 tcp를 사용합니다.
  - **dns: 신뢰성<속도웹페이지: 신뢰성>속도**
  - tcp 는 데이터 전송을 시작하기 전에 3-way-handshake를 사용하는 반면에 udp는 형식적인 예비동작이 없습니다. 따라서 **연결 설정에 드는 비용이 없습니다.**
  - udp는 어떠한 정보도 기록하지 않고 유지할 필요가 없습니다. **도메인 네임을 ip로 변경함으로 항상 많은 클라이언트를 수용하는 dns 서버에게는 연결상태를 유지 하지 않아 정보 기록을 최소화 하는 udp가 알맞습니다.**
  - 따라서 특정 애플리케이션에 할당된 서버는 애플리케이션이 tcp보다 udp에서 동작할 때 **더 많은 클라이언트를 수용**할 수 있습니다.
  - TCP는 end point에서 연결 상태를 유지하며 다음과 같은 파라미터들이 포함된다. ->(수신버퍼, 송신버퍼, congestion control 파라미터, sequence number, ACK number)
  **[ 키워드 : UDP의 신속성, 많은 클라이언트 수용, 속도 ]**
  ## DNS 레코드
  > DNS에 받은 요청을 어떻게 처리할 것인지에 대한 정보
  DNS 레코드(DNS Record)는 DNS 서버가 해당 패킷을 받았을 때 어떤식으로 처리할지를 나타내는 *지침*을 말합니다. 간단히 말하면 DNS 상에서 도메인에 관한 설정을 하기 위해 사용되는 일련의 설정 문자라고 보면 됩니다. DNS 레코드에는 서버가 요청에 응답하는 방법에 대한 다양한 구문과 명령이 포함되어 있습니다.
  [ 키워드 : ]
