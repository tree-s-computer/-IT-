# 알고즘과 프로그램의 차이

알고리즘: 계산이나 작업을 수행하는 순서

## 정수를 비교하여 나열하는 알고리즘

- 작은 숫자를 찾아서 교환하는 선택 정렬
- 알고리즘으로 인정받기 위해서는 어떤 입력 데이터가 들어와도 동일하게 문제를 해결할 수 있는 일반적인 기술이어야 한다.

## 해결법

- 주어진 숫자 중에서 제일 작은 숫자를 찾는다.
- 이를 제일 왼쪽에 있는 숫자와 교환한다.
- 이 예에서는 1이 제일 작기 때문에 7과 위치를 바꾼다. (스위칭)
- 1은 고정되어 움직이지 않는다.
- 남은 숫자중 가장 작은 숫자를 찾아 왼쪽에서 두 번째 숫자와 교환한다.

이렇게 한 번 움직여 숫자 하나가 고정되는 것을 한 **‘라운드’** 라고 한다. 일반적으로 k라운드에서는 남은 숫자중 가장 작은 숫자를 찾아 왼쪽에서k번째 숫자와 교환하여 고정한다.

## 컴퓨터가 알 수 있게 해법을 작성하는 알고리즘 설계

컴퓨터는 정해진 기본 명령을 고속으로 수행할 수 있지만 복잡한 명령을 실행하지는 못한다.

**기본 명령 :** 덧셈이나 메모리의 지정한 주소에 값을 보존하는 것 등

**복잡한 작업:** 기본 명령을 조합해 처리하는 것, **‘n개 숫자를 정렬한다’** 는 것은 컴퓨터에게 복잡한 작업니다.

## 알고리즘을 선택하는 방법

같은 문제를 푸는 알고리즘이 여러 개 있을때 어떤 것을 선택해야 할까 ?

사람이 이해하기 쉬운 알고리즘은 프로그램을 작성하기 쉽다.

저장 공간을 적게 사용하는 알고리즘은 메모리가 제한된 컴퓨터에서도 작동할 수 있다.

하지만 일반적으로 가장 중요한 것은 계산 시간, **즉 입력이 주어진 후에 답이 나올 때 까지 걸리는 시간이다.**

## 숫자 50개를 정렬하는 데 우주의 역사보다 긴 시간이 필요할 수 있다

- **완전 탐색**에 의한 정렬

비효율적인 알고리즘을 선택한다면 ..

1. n개 숫자가 나열된 수열을 하나 만든다.
2. (1)에서 만든 수열이 왼쪽부터 작은 순으로 정렬되었는지 확인한다. 맞으면 출력, 틀리면 (1) 로 돌아가서 다시 정렬

n!=n×(n−1)×(n−2)×⋯×2×1

예를 들어:

- 3개의 숫자 (예: 1, 2, 3)를 나열하는 경우의 수는 3! = 6
  - 가능한 순열: (1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)
- 4개의 숫자 (예: 1, 2, 3, 4)를 나열하는 경우의 수는 4! = 24
  - 가능한 순열: (1, 2, 3, 4), (1, 2, 4, 3), (1, 3, 2, 4), ..., (4, 3, 2, 1)

n개의 숫자를 나열하는 경우를 계산하는 것은 **순열(Permutation)** 문제로, 이는 숫자들의 가능한 모든 배열을 생성하는 것.

### 순열의 개수

- n개의 숫자를 나열하는 경우의 수는 n! (n 팩토리얼)
- n!은 1부터 n까지의 모든 자연수를 곱한 값으로 정의된다.n !=n×(n−1)×(n−2)×⋯×2×1
  n!=n×(n−1)×(n−2)×⋯×2×1n! = n \times (n-1) \times (n-2) \times \dots \times 2 \times 1

예를 들어:

- 3개의 숫자 (예: 1, 2, 3)를 나열하는 경우의 수는 3! = 6
  - 가능한 순열: (1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)
- 4개의 숫자 (예: 1, 2, 3, 4)를 나열하는 경우의 수는 4! = 24
  - 가능한 순열: (1, 2, 3, 4), (1, 2, 4, 3), (1, 3, 2, 4), ..., (4, 3, 2, 1)

### 완전탐색을 사용한 순열 생성

완전탐색 알고리즘을 사용해 n개의 숫자의 순열을 생성하려면, 가능한 모든 순서를 하나씩 시도해 봐야 한다.

예를 들어, 3개의 숫자 {1, 2, 3}에 대해:

1. 첫 번째 자리에는 1, 2, 3 중 하나가 올 수 있다.
2. 두 번째 자리에는 첫 번째 자리에 놓지 않은 두 숫자 중 하나가 올 수 있다.
3. 세 번째 자리에는 남은 하나의 숫자가 온다.

이를 반복하여 모든 가능한 조합을 생성한다. 이 방식은 시간복잡도가 O(n!). n이 커질수록 계산 시간이 기하급수적으로 증가하므로, 순열을 완전탐색으로 해결할 때는 n이 작은 경우에 적합.

- 선택 정렬에 의한 정렬

첫 번째 라운드에서 제일 작은 숫자를 찾기 위해 왼쪽부터 오른쪽까지 최대 n개만 확인하면 된다.
