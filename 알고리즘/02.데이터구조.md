# 데이터의 순서와 위치 관계를 결정한다

컴퓨터는 데이터를 메모리에 저장한다. 메모리는 상자가 일렬로 나열된 형태라고 생각할 수 있다.

데이터를 메모리에 저장할 때 데이터의 순서나 위치 관계를 규정한 것이 데이터 구조 이다.

# 효율적인 데이터 구조로 메모리 사용 효율을 높인다

데이터를 메모리에 저장할 때 목적에 맞게 잘 구조화하면 사용 효율이 높아진다.

데이터는 메모리에 일렬로 저장되지만, 포인터 같은 도구를 사용하면 그래프나 트리와 같은 복잡한 구조도 만들 수 있다.

## 1-2 리스트

리스트는 데이터를 일직선으로 **줄줄이 정렬한 데이터 구조**이다.

데이터의 추가나 삭제는 쉬운 반면, 원하는 데이터에 접근하는 시간은 오래걸린다.

1. 리스트는 개념도다. 각 데이터는 포인터를 가지고 있다.
2. 리스트의 각 데이터는 메모리상에서 연속된 영역에 배치되어 있을 필요가 없다. 보통 멀리 떨어진 영역에 분산되어 배치된다.
3. 연속적으로 배치되어 있지 않고 개별적으로 저장되어 있지 때문에 특정 데이터에 접근하려면 데이터의 포인터를 찾아가야 한다. 이를 순차접근 혹은 시퀀셜 엑세스 라고 한다.
4. [순차접근] Yellow 를 거쳐야 Red에 접근 할 수 있다.
5. 데이터도 쉽게 추가할 수 있다. 추가할 위치의 앞에 있는 데이터의 포인터를 바꾸면 된다.

탐색 :리스트의 맨 처음부터 하나씩 접근해야 하므로 o(n)

추가: 포인터 두 개만 변경하면 되고 이는 n의 값에 영향을 받지 않기 때문에 o(1)

삭제: 마찬가지

## 원형리스트 & 순환리스트

기본적인 리스트의 경우 마지막 데이터는 포인터가 없다. 하지만 마지막 데이터의 포인터가 맨 앞의 데이터를 가리키게 하면 리스트를 고리 모양으로 연결할 수 있다. 이를 원형 리스트 혹은 순환 리스트라고 한다. 이러한 리스트는 **항상 일정한 개수의 최신 데이터를 보관해야 하는 상황**에서 사용되곤 한다.

## 양방향 리스트

각 데이터가 포인터 두개로 앞 뒤 데이터를 가리키게 만든 것. 앞에서 뒤로는 물론 뒤에서 앞으로도 검색 할 수 있어 편리하다.다만 포인터 수가 늘어난 만큼 데이터양이 증가하고 데이터를 저장하기 위한 공간도 늘어난다는 단점이 있다. 또한 데이터를 추가하거나 삭제할 때 변경해야 할 포인터 수도 늘어난다.

## 선형탐색

앞에서부터 차례대로 확인

데이터양에 비례하여 계산 시간이 늘어난다.

## 해시

해시 충돌이 발생할 때 기존 데이터와 리스트로 연결해 해결한다.

해시 테이블은 해시 함수를 사용하여 배열 내 데이터에 빠르게 접근할 수 있다. 그리고 해시값이 출동할때는 리스트를 사용하기 때문에 저장할 데이터 수가 정해져있지 않더라도 유연하게 대응할 수 있다. 해시 테이블에서 사용하는 배열의 크기가 너무 작으면 충돌이 많아져 선형 탐색이 많이 발생한다. 반대로 크기가 너무 크면 데이터가 저장되지 않은 상자가 많아져 메모리 낭비로 이어진다. 배열 크기를 적절하게 설정하는 것이 중요하다.

# 힙

힙은 그래프의 트리 구조중 하나로 **우선순위 큐**를 구현할 때 사용된다. 우선순위 큐는 데이터를 자유롭게 추가할 수 있지만, 꺼낼때는 항상 가장 작은 데이터를 꺼낸다. 힙을 비롯한 트리 구조에서는 각 정점을 노드라고 부른다.

트리 모양은 데이터 개수에 따라 정해진다. 노드는 위에서부터 채워지며, 같은 층에서는 왼쪽부터 채워진다.

**힙에서 데이터를 저장시 자식 노드의 값이 반드시 부모 노드의 값보다 커야 한다는 규칙이 있다.**

따라서 맨 위 노드는 가장 작은 값을 가지게 된다. 데이터를 추가할 때 이 규칙을 지키기 위해 맨 아래츨 왼쪽에 데이터를 추가한다. 부모 노드가 자식 노드보다 더 큰 경우에는 힙의 규칙을 지키기 위해 부모와 자식을 교체한다.

힙은 항상 가장 작은 데이터가 맨 위에 있기 때문에 데이터 개수와 상관 없이 o(1) 시간으로 최솟값을 꺼낼 수 있다. 데이터를 꺼낸 뒤 힙을 재구성 할떄는 맨 끝에 있는 데이터를 맨 위로 옮긴 뒤 자식 노드와 비교하며 밑으로 이동한다. 이 작업 시간은 트리의 높이에 비례한다.

(⇒ 데이터 개가 n이라면 힙의 높이는 log2n이므로 계산 시간은 o(logn)

- O(log n)은 "n번만 곱한다"기보다는, 데이터가 커져도 실행 시간이 천천히 증가하는, 매우 효율적인 알고리즘을 의미

### O(log n)과 n의 차이

- **O(n)**: 데이터의 크기 n에 따라 시간이 **직선적으로 증가.** 예를 들어, 데이터가 2배가 되면, 실행 시간도 2배가 된다.

- **O(log n)**: 데이터의 크기 n이 증가하더라도, 시간이 **로그**만큼만 증가하므로 매우 효율적입니다. 예를 들어, 데이터가 2배가 되어도 실행 시간은 약간만 늘어난다.

## 이진 탐색 트리

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/6a52ed65-b798-46b2-9834-d101f072d7dc/image.png)

이진 탐색 트리는 그래프의 트리 구조로 각 노드에 데이터가 저장된다.

각 노드는 자식 노드를 최대 2개 가진다.

1. 각 노드의 값은 왼쪽 가지에 있는 노드들의 값보다 크다. 예를들어 노드 9는 왼쪽 가지에 있는 노드들의 값보다 크다.마찬가지로 노드15는 왼쪽 가지에 있는 노드들의 값보다 크다.
2. 각 노드의 값은 오른쪽 가지에 있는 노드들의 값보다 작다. 예를들어 노드15는 오른쪼 가지에 있는 노드들의 값보다 작다.

이 두가지 특징을 통해 다음 조건이 성립한다. 먼저 이진 탐색 트리의 최솟값은 제일 위에 있는 노드에서 왼쪽 트리만 탐색하면 찾을 수 있다. 반대로 최댓값은 제일 위에 있는 노드에서 오른쪽 트리만 탐색하면 찾을 수 있다.

이진 탐색 트리는 이진 탐색의 개념을 트리 구조에 적용한 것으로 볼 수 있다. 데이터를 찾거나 추가할 때 현재 위치의 데이터와 크기를 비교하여 왼쪽 혹은 오른쪽으로 진행하여 노드의 위치를 찾는다. 비교 연산은 트리의 높이만큼 수행한다.

따라서 노드 n개가 균형 있게 배치되어 있다면 최대 log2n번 비교하므로 계산시간은 o(logn)이 된다.

트리가 한쪽으로 치우쳐져 세로로 늘어선 모양이 되면 계산 시간은 o(n) 이 된다.

### 보충자료

트리가 한쪽으로 치우치면 형태를 수정하여 항상 균형을 유지하는 것도 있다. 이렇게 검색 효율을 높인 것을 균형 이진 탐색 트리라고 한다. 또한, 앞서 설명한 이진 탐색 트리의 경우 각 노드의 자식 노드가 최대 두 개였는데 이를 m개로 확장하고 자식 노드 수에 자유도를 부여하여 트리 균형을 맞춘 B트리라는 것도 있다.
