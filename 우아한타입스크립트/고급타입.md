# any 타입을 어쩔 수 없이 사용해야 할 때

1. 개발 단계에서 임시로 값을 지정해야 할 때

2. 어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을때
   API 요청 및 응답 처리, 콜백함수 전달, 타입이 잘 정제되지 않아 파악이 힘든 외부 라이브러리 등

3. 값을 예측할 수 없을 때 암묵적으로 사용

# any와 anknown

any : 모든 타입을 허용
TypeScript에서 타입 검사를 느슨하게 하므로 개발 당시에는 문제가 없으나 애플리케이션 또는 웹 페이지 개발 후 예기치 못한 문제가 발생할 가능성이 매우 높다.

unknown : any 타입 외에 다른 타입으로 할당 불가능
any 타입과는 다르게 프로퍼티 또는 연산을 하는 경우 컴파일러가 체크.

unknown 타입은 any 타입과 유사하지만 타입 검사를 강제하고 타입이 식별된 후에 사용할 수 있기 때문에 any 타입보다 더 안전하다.
따라서 데이터 구조를 파악하기 힘들 때 any대신 unknown 타입으로 대체해서 사용하는 방법이 권장된다.

# 튜플

튜플은 타입스크립트 타입 시트템과 대괄호를 사용해서 선언할 수 있다.
리액트의 uesState는 튜플 타입으로 반환한다.
첫 번째 원소는 훅으로부터 생성 및 관리되는 상태 값을 의미하고, 두 번째 원소는 해당 상태를 조작할 수 있는 세터를 의미한다.
useState API 는 배열 원소의 자리마다 명확한 의미를 부여하기 때문에 컴포넌트에서 사용하지 않은 값에 접근하는 오류를 방지할 수 있다.
또한 구조 분해 할당을 사용해서 사용자가 자유롭게 이름을 정할 수 있다.

구조분해 할당은 배열뿐만 아니라 객체에 대해서도 적용할 수 있다.
객체의 경우 사전에 선언된 속성 이름을 통해 값을 가져오므로 튜플보다 유연성은 다소 떨어질 수 있다.

튜플은 배열의 성질을 혼합해서 사용할 수 있다.

1. 특정 인덱스에서 요소를 명확한 타입으로 선언하고 나머지 인덱스에서는 배열처럼 동일한 자료형의 우너소를 개수 제한 없이 받도록 할 수 있음.
2. 또한 옵셔널 프로퍼티를 명시 할 수 있음.

# enum

enum 타입은 주로 문자열 상수를 생성하는 데 사용된다. 이를 통해 응집력 있는 집합 구조체를 만들 수 있으며, 사용자 입장에서도 간편하게 활용할 수 있다.
열거형의 장점

1. 타입 안정성
2. 명확한 의미 전달과 높은 응집력
3. 가독성

이처럼 열거형은 관련이 높은 멤버를 모아 문자열 상수처럼 사용하고자 할 때 유용하게 쓸 수 있다.

## 열거형을 사용할 때 주의할 점

먼저, 숫자로만 이루어져 있거나 타입스크립트가 자동으로 추론한 열거형은 안전하지 않은 결과를 낳을 수 있다.
const enum 으로 열거형을 선언하더라도 숫자 상수로 관리되는 열거형은 선언한 값 이외의 값을 할당하거나 접근할 떄 이를 방지하지 못한다.

반면 문자열 상수 방식으로 선언한 열거형은 미리 선언하지 않은 멤버로 접근을 방지한다.
따라서 문자열 상수 방식으로 열거형을 사용하는 것이 숫자 상수 방식보다 더 안전하며 의도하지 않은 값의 할당이나 접근을 방지하는 데 도움이 된다.

얼겨형은 타입 공간과 값 공간에서 모두 사용된다.

# 인덱스 시그니처

인덱스 시그니처는 특정 타입의 속성 이름은 알 수 없지만, 속성값의 타입을 알고 있을 때 사용하는 문법이다.

# 인덱스드 엑세스 타입

# 맵드 타입

맵드 타입은 타른 타입을 기반으로 한 타입을 선업할 때 사용하는 문법이다.
맵드 타입에서 매핑할 떄는 readonly 와 ? 를 수식어로 적용할 수 있다.

# 제네릭

제네릭은 배열 생성 시점에 원하는 타입으로 특정할 수 있다. 다시 말해 제네릭을 사용하면 배열 요소가 전부 동일한 타입이라는 것을 보장할 수 있다.
제네릭을 사용할 때 주의해야 할 점이 있다. 파일 확장자가 tsx일 때 화살표 함수에 제네릭을 사용하면 에러가 발생한다.
tsx는 타입스크립트 + jsx 이므로 제네릭의 꺾쇠 괄호와 태그의 꺾쇠 괄호를 혼동하여 문제가 생기는 것이다.
이러한 상황을 피하기 위해 제네릭 부분에 extends 키워드를 사용하여 컴파일러에게 특정 타입의 하위 타입만 올 수 있음을 확실히 알려주면 된다.
보통 제네릭을 사용할 때는 func0tion 키워드로 선언하는 경우가 많다.

### 에러발생

const arrowExampeFunction = <T>(arg : T):T[] => { return ~ }

### 에러발생 x

const arrowExampeFunction2 = <T extends {}>(arg : T) : T[]=>{return ~ }
