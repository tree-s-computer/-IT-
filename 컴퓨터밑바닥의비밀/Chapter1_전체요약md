> 프로그래밍 언어는 프로그래머가 컴퓨터에 명령을 내리는 도구일 뿐이다.

### 내가 작성한 코드를 컴퓨터가 어떻게 인식하는가 ?

- 컴파일러가 실행 파일을 생성하면 실행할수 있다?
- 컴파일러는 어떻게 코드를 기반으로 실행파일을 생성할까 ?
- 또는 실행 파일은 어떤 형태로, 어떻게 실행될까 ?

### 영리한 인류는 간단한 스위치를 조합하면 복잡한 불 논리를 표현할 수 있다는 사실을 발견하고 이를 기반으로 CPU를 만들었다.

- 단세포 생물처럼 매우 원시적이다.
- 데이터를 한곳에서 다른 곳으로 옮기고 간단히 연산한 후 다시 그 데이터를 또 다른 자리로 옮기는 작업 외에는 할 줄 모른다. (옮기고,연산하고,옮기고)
- 무엇과도 비교할 수 없는 장점은 바로 엄청나게 빠르다는 것이다.

### CPU가 등장한 이후, 인간은 두 번째 두뇌를 가지게 되었다.

옛날에는 **천공카드**를 이용하여 컴퓨터 작업을 제어했다.

**\*천공 카드**(穿孔-, punched card)는 데이터를 표현하기 위해 규칙에 따라 직사각형 모양의 구멍을 뚫어 사용하는 [종이](https://ko.wikipedia.org/wiki/%EC%A2%85%EC%9D%B4) 카드로서 초기의 저장매체이다. 천공 위치에 구멍을 뚫거나 뚫지 않음으로서 하나의 [비트](<https://ko.wikipedia.org/wiki/%EB%B9%84%ED%8A%B8_(%EB%8B%A8%EC%9C%84)>)를 나타날 수 있다

## 어셈블리어

종이와 0과 1로만 소통하는 것이 너무 힘들다.

따라서 **기계어와 해당 특정 작업**을 간단하게 대응시켜 기계어를 인간이 읽고 이해할 수 있는 단어와 대응시켰다. 처음으로 인간이 직접 인식할 수 있는 프로그래밍 언어가 탄생한 것이다.

어셈블리어는 저수준 언어이다.

다시 말해 저수준 언어는 모든 세부 사항에 대해 신경을 써야 한다는 의미이다 .

“물한잔 주세요.” 를 어셈블리어로 표현하려면 수 많은 동작과 지시를 해야한다.

인간의 추상적인 표현에 익숙하지 않다는 말이다. 그렇다면 인간과 기계 사이의 거리를 좁힐 수 있는 방법이 있을까 ?

인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 자동으로 변환 할 수 있는 방법이 있다면 생산성을 획기적으로 높일 수 있을 것이다. 우리는 이 문제를 해결해야한다.

열심히 연구한 결과, 세부 사항이 **규칙 또는 패턴으**로 가득하다는 것을 발견한다.

CPU가 실행하는 명령어는 매우 단도직입적이다.

물컵을 찾는다.

오른손을 들어올린다.

물컵을 잡는다.

수도꼭지로 이동한다.

왼손을 뻗는다.

수도꼭지를 연다.

뒤로 180도 돈다.

이 단도직입적인 명령어에 **문 또는 문장**이라는 이름을 붙였다.

이 규칙을 인간의 방식으로 표현한다면 만약 -라면, -하고 .. 그렇지 않다면 - 한다. 가 되는 것이다.

(별표는 매개변수)

이는 인간이 사용하는 언어에 매우 가깝기 때문에 어셈블리어와 비교하면 비약적인 발전이다.

### 그렇다면 blabla도 단순한 문장일까 ?

확실히 아니다. 문장이 될 수도 있고, 조건에 따른 이동인 if else 일 수도 있고, while 일수도, 함수 호출일 수도 있다.

그저 단계별로 중첩되는 것에 불과하지만, 재귀는 원래 이것을 표현하려고 만든 것이다.

구문에 따라 코드를 작성할 수 있는데, 이 코드는 사실 **문자열**에 불과하다.

### 그렇다면 컴퓨터가 이 문자열을 어떻게 이해하게 할 수 있을까 ?

재귀 구문에 따라 작성된 코드를 트리 구조로 표현할 수 있다. 이것을 **구문트리**로 표현한 것이다.

**\*구문 트리**(abstract syntax tree, AST), 또는 간단히 **구문 트리**(syntax tree)는 [프로그래밍 언어](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4)로 작성된 [소스 코드](https://ko.wikipedia.org/wiki/%EC%86%8C%EC%8A%A4_%EC%BD%94%EB%93%9C)의 추상 [구문](https://ko.wikipedia.org/wiki/%ED%86%B5%EC%82%AC%EB%A1%A0) 구조의 [트리](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC)이다.

### 우수한 번역가 : 컴파일러

컴퓬터는 언어를 처리할 때 구문 정의에 따라 **트리 형태로 코드를 구성**할 수 있다.

이 트리는 구문에 따라 생성되기 때문에 구문트리라는 고급스러운 이름을 붙였다.

- AST (추상구문트리)

AST는 일반적으로 컴파일러의 [구문 분석](https://ko.wikipedia.org/wiki/%EA%B5%AC%EB%AC%B8_%EB%B6%84%EC%84%9D) 단계의 결과물이다. 컴파일러가 요구하는 여러 단계를 통해 프로그램의 중간 표현의 역할을 하며 컴파일러의 최종 결과물에 대해 강력한 영향을 준다.

⇒ AST는 **구문 분석 단계의 결과물,** 컴파일의 최종 단계에서 생성되는 결과물은 **기계어 코드**이다. AST는 컴파일러의 여러 중간 단계에 걸쳐 사용되며 최적화 및 코드 생성에 중요한 역할을 한다..

이제 코드를 트리 형태로 표현할 수 있다. 매우 간단히 기계 명령어로 번역하기만 하면 그 결과를 **부모 노드**에 적용할 수 있다. 이렇게 번역 결과를 차례대로 부모 노드에 적용하는 방식으로 올라가다 보면 결국 전체 트리를 구체적인 기계 명령어로 번역할 수 있다.

⇒ 여기까지, 리프노드(부모가 없는 노드)에서부터 부모로 적용하는 방식으로 번역을 한다고 이해함.

---

## 인류의 또 다른 문제, 각양각색의 다양한 CPU 를 실행할 방법이 없다.

영어가 국제 표준언어인것처럼, CPU는 기계 명령어를 실행하는 존재라는 것을 떠올려보자.

직접 **표준 명령어 집합을 정의**해 CPU의 기계 명령어 실행 과정을 모방하는 프로그램을 작성하여 사용할 수도 있을 것이다.

CPU 시뮬레이션 프로그램에 **가상머신** 이라는 이름을 붙였다.

이 가상머신에는 인터프리터라는 별명도 붙어있다.

1. **가상머신이 인터프리터로 작동하는 경우**:
   - **JVM(Java Virtual Machine)**처럼 가상머신이 바이트코드를 읽고 해석하여 실행하는 경우, 가상머신이 인터프리터 역할을 합니다.
   - 이 경우, 가상머신은 프로그램을 실행하기 위한 가상 환경을 제공하고, 동시에 프로그램의 명령을 해석하고 실행합니다.
2. **인터프리터가 가상머신 위에서 실행되는 경우**:
   - 어떤 경우에는 인터프리터가 가상머신 위에서 실행될 수 있습니다. 예를 들어, Python 인터프리터가 Java Virtual Machine 위에서 실행될 수 있습니다.

---

### 컴파일러는 어떻게 작동하는 것일까 ?

컴파일러는 고수준 언어를 저수준 언어로 번역하는 프로그램이다.

인간이 인식할 수 있는 단어로 코드를 작성하면 코드는 일반적인 텍스트 파일 형태의 파일로 저장되는데, 이를 소스파일이라고 한다. 컴파일러는 이 소스 파일을 **실행 파일 형태**로 뱉어낸다.

(이 파일은 완성 형태가 아니다. 파일을 열어보면 인간이 읽을 수 있는 코드의 형태가 아니라는 뜻이다.)

**CPU는 이런 추상적인 표현을 직접 이해할 수 없다.**

컴파일러는 먼저 각 항목을 잘게 쪼갠다. 각 항목에 추가로 정보를 결합한 것을 전문 용어로 토큰 이라고 한다. 컴파일러가 하는

(1) **첫 번째 작업은 소스 코드를 돌아다니면서 모든 토큰을 찾아내는 것이다.** (⇒ 이것을 어휘분석 이라고 한다.)

(2) 소스 코드가 하나의 토큰으로 바뀌었다. 프로그래머가 전달하고자 하는 토큰 의도를 표현해야 한다. (⇒ 컴파일러가 구문에 따라 토큰을 처리해야 한다는 것은 무슨 의미일까, 문구를 해석하는데 이런 과정을 해석 <파싱> 이라고 한다.)

(3) 구문에 따라 해석해 낸 구조를 구문 트리로 표현한다.

이 트리를 생성하는 전체 과정을 **구문 분석** 이라고 한다. 구문 트리에 이상이 없는지 확인해야 한다. 이 단계를 **의미 분석**이라고 한다.

(4) 구문 트리를 기반으로 중간 코드를 생성한다. (물론 어떤 경우에는 중간 코드에 추가적인 최적화가 진행되기도 한다.)

(5) 이 과정이 완료되면 중간 코드를 어셈블리어 코드로 변환한다.

(6) 마지막으로, 컴파일러는 이 어셈블리어 코드를 기계 명령어로 변환한다.

❣️  주로 **파스트리 => 추상 구문 트리 -> 기계어 코드** 순으로 생성한다.

❣️  컴파일하다보면 오류를 표시해주는데 그걸 파스트리를 만들다가 실패해서 보여주는것이다.

---

## 링커의 말할 수 없는 비밀

일반적으로 외부 코드는 **정적/동적 라이브러리**로 구분된다.

링커는 컴파일러가 생성한 대상 파일 여러개를 하나로 묶어 **하나의 최종 실행 파일을 생성**한다.

우리가 작성한 프로그래밍에서 종속성이 올바르게 설정되어있는지, 우리가 참조하고 있는 외부 심벌에 대한 실제 구현이 있든지 단 하나만 있어야 한다. 링커는 이를 찾아내 연결하는 작업을 한다. ⇒ 이 과정을 **심벌 해석** 이라고 한다.

- 재배치

컴파일될때 어디에 배치 될 수 알 수 없지만 실행파일이 생성되는 시점에 임시 표시해두었던 메모리 주소가 실제 메모리 주소로 대체 되는 것

- 심벌

전역변수, 함수의 이름을 포함하는 모든 변수 이름

참고로 지역변수는 외부 모듈에서 참조할 수 없기 떄문에 링커의 관심 대상이 아니다.

컴파일러는 링커에게 정보를 알려주는데, 어떻게 알려주는걸까 ?

컴파일러는 **기계 명령어를 생성**할 뿐만 아니라 이 **명령어를 실행시키는 데이터**도 생성한다.

이 데이터는 대상 파일에 반드시 포함되어야 한다.

대상 파일에 포함 되어있는 매우 중요한 두 영역,

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/eb34d3e7-daa3-4e4b-9954-8a9b155f9ddc/Untitled.png)

**명령어 부분** : 소스 파일에 정의된 함수에서 변환된 기계 명령어가 저장되는 부분 (코드 영역)

**데이터 부분 :** 소스 파일의 전역 변수가 저장되는 부분 (데이터 영역)

참고로 로컬 변수는 프로그램이 실행 된 후 스택에서 생성되고 사용되면 제거되기 때문에 대상파일에 별도로 저장되지 않는다.

컴파일러는 링커의 부담을 줄여주기 위해 다른 작업을 더 하는데, 소스 파일마다 외부에서 참조 가능한 심벌이 어떤 것인지 그 정보를 기록하고 어떤 외부 심벌을 참조하고 있는지 기록한다. 이렇게 컴파일러가 외부 심벌 정보를 기록하는 표를 **심벌 테이블** 이라고 한다

*대상 파일*은 링커가 작업 과정에서 필수적으로 사용하는 파일이다.

---

### 헤더파일

```jsx
int sum(int a, int b);
```

- 헤더파일은 함수의 선언만을 담고 있다.
- 변수도 선언할 수 있다.
- why?? 헤더파일에 선언만을 담는 이유는??
- 심볼(\*) = 이름 찾기

## 정적 라이브러리

정적 라이브러리 기능을 사용하면 소스 파일 여러 개를 미리 개별적으로 컴파일하고 링크하여 정적 라이브러리로 생성할 수 있다. 이때 기억할 점은 소스 파일마다 단독으로 컴파일을 한다는 것이다.

이후 실행 파일을 생성할 때는 자신의 코드만 컴파일 하며, 미리 컴파일 완료된 정적 라이브러리는 다시 컴파일할 필요 없이 링크 과정에서 그대로 실행 파일에 복제 된다. 외부 코드를 매번 컴파일하지 않아도 되기 때문에 컴파일 속도가 빨라진다.

정적 링크는 라이브러리를 실행 파일에 직접 복사하기 때문에 실행 파일은 모두 동일한 코드와 데이터의 복사본을 갖게된다. 만약 해당 라이브러리를 사용하는 실행 파일이 500개라면 , 1GB크기의 데이터가 중복된 데이터로 구성된다는 의미이다.

⇒ 그렇다면 이 문제를 어떻게 해결할수 있을까?

바로 동적 라이브러리를 사용하는 것이다.

## 동적 라이브러리

정적 라이브러리를 사용하면 정적 라이브러리의 코드 영역과 데이터 영역을 모두 한데 묶어 실행 파일에 복사한다.

동적 라이브러리를 사용하면 정적 라이브러리가 실행 파일에 라이브러리 내용을 모두 복사했던 것과 달리, 참조된 동적 라이브러리 이름, 심벌 테이블, 재배치 정보 등 만 포함된다. 실행 파일의 크기를 확실히 줄일 수 있다는 점에서 매우 중요하다.

참조된 동적 라이브러리의 필수 정보는 실행 파일 내 저장되며, 이 필수는 동적 링크가 일어날 때 사용된다.

**정적** : 컴파일 단계에서 실행 파일에 함께 복사된다. 실행 파일에 정적 라이브러리의 전체 내용이 포함된다.

**동적** : 정적 라이브러리에 의존하는 실행 파일에는 컴파일 단계에서 필수 정보만 저장됨, 동적 링크는 실제 프로그램의 실행 시점까지 미룸.

### 동적 링크의 두가지 방식

1. 프로그램이 메모리에 적재될 때 (적재 : 실행 파일을 실행하기 위해 디스크에서 읽어 메모리의 특정 영역으로 이동시키는 과정) 적재하고 나면 실행 파일이 **동적 라이브러리에 의존하는지** 여부를 확인할 수 있다. 동적 라이브러리가 필요하면 동적 링커라는 별도의 프로세스가 실행되어 참조하는 동적 라이브러리 존재 여부와 위치, 심벌 메모리의 위치 등을 확인하여 과정을 마무리한다. 동적 링커를 사용하려면 어떤 동적 라이브러리를 사용하는지 컴파일러에 명시적으로 알려주어야 한다.

1. 적재 중 고정적으로 일어나는 동적 링크 외에도 프로그램이 먼저 실행된 후, 프로그램의 실행시간 동안 **코드가 직접 동적 링크를 실행할** 수 있다. 실행 시간 동적 링크는 실행 파일이 실행될 때 까지 어떤 동적 라이브러리에 의존하는지 알 필요 없기 때문에 좀 더 동적인 링크 방식이다. 런타임 동적 링크는 링크 과정을 프로그램이 실행된 이후로 미룬다. (이 방식에서는 실행 파일을 생성하는 과정에서 실행 파일 내부에 동적 라이브러리 정보가 저장되지 않는다.)

**실행시간 :** CPU가 프로그램을 실행하기 시작한 시점부터 실행이 완료되어 프로그램이 종료된 시점까지의 시간

### 동적 라이브러리의 장단점

동적 라이브러리는 의존 프로그램 개수가 얼마가 되었든 상관 없이 디스크에는 동적 라이브러리의 복사본 하나만 저장된다. 메모리에 적재되는 코드 또한 마찬가지다. 필요한 리소스를 대폭 절약할 수 있기 때문에 공유 라이브러리 라고도 한다.

수정시 실행 파일을 매번 컴파일 할 필요 없이 동적 라이브러리만 새 버전으로 교체하면 되기 때문에 버그 수정이 매우 쉽다.

❣️ 여기서, 1:1로 대응 할 수 없지만. .

axios 가 동적 라이브러리라고 생각했지만, 아니다. 왜냐하면 install 을 해도 웹팩이 하나의 파일로 만들어서 파일 안에 담겨서 찾아가기 때문이다. 그렇기 때문에 굳이 따지자면 axios 는 **정적 라이브러리와 비슷**하다고 볼 수 있다.

**동적 라이브러리와 비슷한 방식은 오히려 script cdn방식이다.**
노드모듈에도 포함이 안되고, 실행될때 브라우저가 동적으로 갖고와서 로드를 하기 떄문이다.

=> 컴파일해서 실행파일이 나오는 **정적/동적 라이브러리와 똑같진 않고 방식만 가져온것**이다.

### 플러그인

사전에 함수 여러개를 미리 정의해 두고, 플로그인에서는 이 함수들을 구현한다.

### 단점

- 정적 링크를 사용할때보다 성능이 약간 떨어진다.
- 동적 라이브러리의 코드는 임의이 메모리 절대 주소로 참조 할 수 없다. 왜냐하면 복사본만 존재하고 여러 프로세스를 공유할 수 있기 때문이다.
- 동적 라이브러리는 다른 프로세스를 통해 적재되고 나면 서로 다른 주소 공간을 가지게 된다.
- 적재할 때 동적 링크를 수행하는 프로그램은 **실행파일만으로는 실행이 불가능**하다. 즉, 동적 라이브러리를 제공하지 않거나 그 버전이 호환되지 않을 경우 프로그램이 실행되지 않는다. 이러한 종속성 문제로 설치와 배포에 어려움을 겪을 수 있다.

### [예시 파일](https://github.com/gypified/libmp3lame/blob/master/INSTALL)

**정적라이브러리:** libmp3lame.a,

**동적 라이브러리:** [libmp3lame.so](http://libmp3lame.so/)

(컴파일하면 그런 파일들이 만들어진다는 뜻)

### 재배치

링커가 실행파일을 생성할때 프로그램이 실행되는 시점에 함수가 적재될 메모리 주소를 확정해야 한다. call 명령어 뒤에 들어갈 메모리 주소를 링커가 어떻게 알 수 있을까 ? **컴파일러는 컴파일을 통해 대상 파일을 생성할때 어디에 적재될지, 어디에 넣어야 할 지 알 수 없다.** 이렇게 컴파일러가 넘긴 부분을 링커가 채워야 한다. 링커는 이 명령어를 찾아 함수가 최종적으로 실행되는 시점의 메모리 주소로 변경해야 한다는 것을 어떻게 알 수 있을까 ?

실행시 메모리 주소를 알 수 없는 변수는 대상 파일에 저장된다.

대상 파일에서 각 유형의 영역이 모두 결합되면 모든 기계

## 가상 메모리와 프로그램 메모리 구조

커널

스택영역

힙영역

데이터 영역 ( 실행 파일의 내용이

코드 영역 메모리에 적재 되는 곳 )

프로그램이 실행되면 해당 프로그램의 프로세스가 메모리에 적재된다. 모든 프로그램은 실행된 후 코드 영역이 예외 없이 메모리 주소 **0x400000에서 시작**된다.

여기서 A와 B가 동시에 실행 중이라고 가정할 때 CPU가 메모리 주소 - 에서 가져오는 기계 명령어는 A코드일까, B코드일까 ? A,B에서 각각 가져올 수 있는데 그 데이터는 서로 동일하지 않다. 이렇게 마법 같은 일이 가능하게 하는 것은 바로 운영 체제의 가상 메모리 기술이다. (물리적으로 존재하지 않는 가짜 메모리)

실제로 시스템에 설치 된 물리적 메모리가 얼마나 됐든 자식이 4GB를 독점하고 있다고 생각한다. 논리로만 존재하는 허상일뿐이다.

실행시 코드영역,스택영역, 시작 메모리 주소는 항상 고정되어 있기 때문에 심벌의 메모리 주소를 확인 할 수 있는 것이다. 하지만 사실상 **링커는 프로그램이 실행될때 물리 메모리는 신경쓰지 않는다.**

사상 관계를 기록한 표를 페이지 테이블 이라고 한다.

논리적,물리적 메모리 주소를 매칭시키는 테이블의 이름이다.

1. 모든 가상메모리는 표준화 되어있고 크키가 동일하다. 배치되는 순서는 동일하다.
2. 물리메모리와 가상 메모리의 크기는 무관하다. 물리 메모리에는 힙,스택영역 등을 구분하지 않는다.
3. 모든 프로세스는 자신만의 페이지 테이블을 가지고 있다.
