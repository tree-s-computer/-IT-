1. 여러분이 프로그래밍 언어를 발명한다면 ?
2. 컴파일러는 어떻게 작동하는 것일까 ?
3. 링커의 말할 수 없는 비밀
4. 컴퓨터 과학에서 추상화가 중요한 이유
5. 요약

- 컴파일러는 어떻게 코드를 기반으로 실행파일을 생성(build) 할까?

1. CPU는 단세포 생물처럼 매우 원시적이다. 데이터를 한곳에서 다른 곳으로 옮기고 간단히 연산한 후 다시 그 데이터를 또 다른 자리로 옮기는 작업 외에는 할 줄 모른다.
   하지만 무엇과도 비교할 수 없는 장점은 '엄청나게 빠르다는 것' 이다.

2. 010101.. 로 소통을 시작하다,

3. 처음으로 인간이 직접 인식할 수 있는 프로그래밍언어인 어셈블리어가 탄생했다.

### 수열

```jsx
function fibonacci(n) {
  // base cases
  if (n === 0) {
    return 0;
  }
  if (n === 1) {
    return 1;
  }
  // recursive case
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// 예시: f(6)을 계산해보자
console.log(fibonacci(6)); // 출력: 8
```

# 우수한 번역가 : 컴파일러

컴퓨터는 프로그래밍 언어를 처리할 때 구문 정의에 따라 트리 형태로 코드를 구성할 수 있다.
이 트리는 구문에 따라 생성되기 때문에 여기에 구문 트리라는 매우 고급스러운 이름을 붙였다.

컴파일러는 각 항목을 쪼개어 키워드로 구분한다.
소스코드를 돌아 다니면서 모든 토큰을 찾아낸다.
이렇게 소스코드에서 토큰을 추출하는 과정을 어휘분석 이라고 한다.

이제 소스 코드가 하나의 토큰으로 바뀌었다.
그 후 파싱을 하고, 구문에 따라 해석 해 트리로 구조를 표현한다.

구문 트리를 기반으로 중간 코드를 생성한다.

### 중간코드 예시

```jsx

a = 1
b = 2
goto B
A : b = b - 1
B : if a < b goto A

```

이 과정이 완료되면 컴파일러는 앞의 중간코드를 어셈블리어로 변환한다.
마지막으로, 컴파일러는 어셈블리어 코드를 기계 명령어로 변환한다.

# 과정 재정리

1. 어휘 분석 (Lexical Analysis)
   목적: 소스 코드를 토큰(token)으로 분해
   작업: 입력된 소스 코드를 읽고, 의미 있는 기초 단위(토큰)로 분할합니다. 토큰은 변수명, 키워드, 연산자, 리터럴 등으로 구성됩니다.
   도구: 어휘 분석기는 일반적으로 정규 표현식과 유한 자동 기계(finite automata)를 사용합니다.
2. 구문 분석 (Syntax Analysis)
   목적: 토큰의 구조를 분석하여 문법적으로 올바른지 확인
   작업: 어휘 분석기가 생성한 토큰을 받아, 문법 규칙에 맞게 파싱 트리(parse tree)나 추상 구문 트리(Abstract Syntax Tree, AST)를 생성합니다.
   도구: 구문 분석기는 주로 파싱 알고리즘(LR, LL, etc.)과 문법을 정의하는 문법 규칙을 사용합니다.
3. 의미 분석 (Semantic Analysis)
   목적: AST의 의미가 언어의 의미 규칙에 맞는지 검사
   작업: 변수의 선언과 사용, 자료형 검사, 범위 규칙 확인 등을 수행합니다. 이 단계에서 심볼 테이블(Symbol Table)이 사용됩니다.
   도구: 의미 분석기는 주로 타입 시스템과 제약 조건을 사용합니다.
4. 중간 코드 생성 (Intermediate Code Generation)
   목적: 기계 독립적인 중간 코드를 생성
   작업: AST를 기반으로 중간 표현(예: 3주소 코드, 트리, P-코드 등)을 생성합니다. 이 중간 코드는 최적화와 코드 생성에 사용됩니다.
   도구: 중간 코드 생성기는 중간 표현 언어를 정의하고, 이를 생성하는 변환 규칙을 사용합니다.
5. 코드 최적화 (Code Optimization)
   목적: 중간 코드를 최적화하여 실행 시간을 줄이거나 메모리 사용을 최소화
   작업: 불필요한 코드 제거, 루프 최적화, 인라인 확장 등 다양한 최적화 기법을 적용합니다.
   도구: 최적화 기법은 데이터 흐름 분석, 제어 흐름 그래프 등을 사용합니다.
6. 코드 생성 (Code Generation)
   목적: 최적화된 중간 코드를 실제 기계어로 변환
   작업: 중간 코드를 타깃 머신의 어셈블리어 또는 기계어로 변환합니다. 이 단계에서 레지스터 할당, 명령어 선택 등이 이루어집니다.
   도구: 코드 생성기는 기계어 명령 집합과 레지스터 사용 규칙을 사용합니다.
7. 코드 연결 및 로드 (Linking and Loading)
   목적: 여러 개의 개별적인 오브젝트 파일을 결합하여 실행 가능한 프로그램을 생성
   작업: 코드와 데이터의 주소를 결정하고, 외부 라이브러리와의 링크 작업을 수행합니다.
   도구: 링커(linker)와 로더(loader)가 사용됩니다.

# 링커의 말할 수 없는 비밀

링커는 압축 프로그램이 파일 여러 개를 하나의 압축 파일로 묶어 주는 것처럼, 컴파일러가 생성한 대상 파일 여러 개를 하나로 묶어 하나의 최종 실행 파일을 생성한다.
소스 코드를 담고 있는 func.c 파일이 있다고 가정한다.
이 파일을 컴파일하면 func.o라는 이름의 기계 명령어에 해당하는 코드를 저장하는 파일이 생성되는데, 이 파일을 대상 파일이라고 한다.

# 심벌해석: 수요와 공급

심벌은 무엇을 뜻할까? 바로 전역변수와 함수 이름을 포함하는 모든 변수 이름을 의미한다.
지역 변수는 모듈 내에서만 사용되어 **외부 모듈에서 참조할 수 없기 때문에** 링커의 관심 대상이 아니다.

링커가 실제로 관심을 갖는 것은 전역변수이다.

1. 소스 파일에 다른 모듈에서 참조 할 수 있는 심벌 두개가 있다는 것
2. 소스 파일이 다른 모듈에서 정의한 심벌 두 개를 참조한다는

두가지 정보를 알고 있어야 한다.
이러한 정보는 컴파일러가 알려준다.

# 컴파일러의 역할

컴파일 과정에서 외부에서 정의된 전역 변수나 함수를 발견할 경우,
해당 변수의 선언이 존재한 그 변수가 실제로 정의되었는지 여부는 신경쓰지 않고 유쾌하게 다음 단계로 넘어갈 것이다.
참조된 변수 정의를 찾는 일은 컴파일러가 아닌 링커의 몫이다.

컴파일러는 소스 파일마다 외부에서 참조 가능한 심벌이 어떤 것인지 정보를 기록하고, 반대로 어떤 외부 심벌을 참조하고 있는지도 기록한다.
이것을심벌 테이블 이라고 한다.

### 심벌 테이블에 표현 되는 것

1. 내가 정의한 심벌, 즉 다른 모듈에서 사용할 수 있는 심벌
2. 내가 사용하는 외부 심벌

의문 : 어떤 것인지를 기록하는 과정과 참조된 변수 정의를 찾는 일은 다른 것인가
=> 컴파일러는 이 테이블을 대상 파일에 저장하고, 링커는 이 파일을 보고 필요한 정보를 얻어내는 것이다. (기록자 & 참조자 )
