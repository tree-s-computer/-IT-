콜백함수, 동기화, 비동기화, 블로킹, 논블로킹은 도대체 무슨뜻일까 ?

### CPU는 다음 두 가지 사항만 알고있다.

1. 메모리에서 명령어를 하나 가져온다.
2. 명령어를 실행한 후 1로 돌아간다.

**CPU**: 프로세스? 스레드? 몰라 그런거..

PC 레지스터는 다음에 실행할 명령어 주소를 저장한다. PC 레지스터가 저장하는 주소는 기본적으로 1씩 자동으로 증가한다. 보통 CPU가 주소를 하나씩 증가하면서 차례대로 명령어를 실행하는데 if 또는 함수 호출같은 명령어를 만나면 실행순서가 파괴된다.

### **명령어는 어디에 저장되어 있는가?**

⇒ 메모리에 저장되어있다. 메모리에 저장된 명령어는 **디스크에 저장된 실행파일에 적재**되고, 그 실행 파일은 컴파일러로 생성된다.

컴파일러는 프로그램이 작성된 코드를 기반으로 명령어를 생성한다.

### **CPU가 프로그램을 실행하게 하려면?**

⇒ 실행 파일을 수동으로 메모리에 복사한 후, main 함수에 해당하는 첫 번째 기계 명령어를 메모리에서 찾아 그 주소를 PC 레지스터에 적재하면 된다. 이렇게 하면 운영체제가 없어도 우리가 직접 CPU에 프로그램을 실행하도록 할 수 있다.

1. 프로그램을 적재할수 있는 적절한 크기의 메모리 영역을 찾아야하고,
2. CPU 레지스터를 초기화하고 함수의 진입 포인트를 찾아 PC레지스터를 설정해야한다.

### **수동으로 프로그램 실행하는 방법의 단점**

1. 한번에 하나의 프로그램만 실행 가능
2. 특정 드라이버와 연결해야하고, 외부 장치 연결 불가능
3. 라이브러리 사용 불가능
4. 상호 인터페이스 직접 구현해야함

**CPU는 한번에 하나만 실행할수 있지만 동시에 실행되는것처럼 보이게 하는 방법 :** A를 실행했다 잠깐 중지하고 B의 실행으로 넘어가기 (context)

이런 방법을 사용하기 위해 다음과 같이 프로그램 실행 상태를 저장하고 복구할 때 사용할 구조체를 정의하는 코드를 직접 작성하기 시작한다.

실행 중인 모든 프로그램은 필요한 정보를 기록할 수 있는 형태의 구조체를 가지고 있어야하는데, 이런 원칙에 따라 \*‘**프로세스’\*** 라는 이름이 붙었다.

모든 사람이 프로그램을 자동으로 적재해주는 도구, 멀티태스킹을 실현해주는 프로세스 관리 도구의 같은 프로그램을 **‘운영체제’** 라고 이름을 붙였다.

운영체제는 뒤에서 실행중인 타 프로세스가 몇갠지, CPU가 몇갠지, 물리 메모리의 용량이 얼마인지 신경쓰지 않을 수 있게 해준다. 고급 프로그래밍 언어, 컴파일러, 링커, 운영체제는 철저하게 프로그래머의 생산성을 발휘할 수 있게 도와주는 초석에 해당하는 소프트웨어 제품군이다.

운영체제의 가상 메모리는 프로세스가 표준적인 메모리 크기를 독점적으로 사용하는 것처럼 보이게 한다.

### 프로세스 주소 공간

코드 영역 : 코드를 컴파일하여 생성된 기계 명령어가 저장된다.

데이터 영역 : 전역 변수 등이 저장된다.

힙 영역 : mallic 함수가 요청을 반환한 메모리가 여기에 할당된다.

스택 영역 : 함수의 실행 시간 스택이다.

### **다중 프로세스 프로그래밍의 단점**

- 프로세스를 생성할때 비교적 큰 부담

자체적인 주소 공간을 가지고있기 때문에 복잡

**프로세스 주소 공간에 저장되는 것 :** CPU가 실행하는 기계 명령어, 함수가 실행될 때 스택 정보

프로세스의 단점은 진입 함수가 하나밖에 없어 기계 명령어를 한번에 하나의 CPU에서만 실행할수 있다는 것. 그렇다면 CPU여러개가 동일한 프로세스의 기계 명령어를 실행하게 할 방법은 없을까?

스레드 사이에는 근본적인 통신 개념이 존재하지 않음. 다중 프로세스 프로그래밍처럼 다른 주소 공간이 아닌 동일한 프로세스 공간에 속해있기 때문.

스레드는 운영체제 계층에 구현되며 코어 개수와는 무관하다.스레드는 각자 자신만의 스택 영역을 가지고 있고, 스레드 또한 이를 인지하고있다.

**상호배제:** 동시 프로그래밍에서 공유 불가능한 자원의 동시 사용을 피하기 위해 사용되는 알고리즘

동기화

### 스레드가 처리해야하는 작업

긴 작업, 짧은 작업

### 짧은 작업의 점

1. 생성과 종료에 많은 시간 허비
2. 독립적인 스택 영역이 필요해 메모리와 기타 리소스 소비
3. 스레드간 전환 부담

### 스레드 풀의 개념

스레드를 여러 개 **미리 생성**하고 스레드가 처리할 작업이 생기면 해당 스레드에 처리를 요청하는것

스레드풀에 전달되는 작업은

1. 처리할 데이터
2. 데이터를 처리하는 함수

로 구성된다.

```jsx
stuck task
{
void *data // 작업이 처리할 데이터
handler handle // 데이터 처리 함수
}
```

스레드 풀의 스레드 수가 너무 적다면 CPU를 최대한 활용할 수 없으며, 너무 많은 스레드를 생성하면 반대로 시스템의 성능 저하, 메모리의 과다한 점유, 스레드 전환으로 생기는 부담 등 문제가 발생한다.

## 스레드 전용 리소스

스레드는 함수 실행이다. 함수 실행에는 항상 하나의 시작점이 존재하는데, 이 시작점이 바로 진행함수이다. 그렇다면 함수 실행에는 어떤 정보가 존재할까 ?

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/b3c0f3ee-838f-4ec1-a917-874c3f562527/Untitled.png)

함수 실행 시간 정보는 스택 영역을 구성하는 스택 프레임에 저장된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/68906b6d-91f6-464f-ac7b-38ce1fb14fe0/Untitled.png)

**스레드는** 프로세스 주소 공간에서 스택 영역을 제외한 **나머지 영역을 모두 공유**한다.

### 코드 영역

코드 영역에는 프로그래머가 작성한 코드, 더 정확하게는 컴파일한 후 생성된 실행 가능한 기계 명령어가 저장된다. 코드 영역은 스레드 간에 공유되므로 어떤 함수든지 모두 스레드에 적재하여 실행할수 있고, 특정 함수를 특정 스레드에서만 실행되게 하는것은 불가능하다.

코드 영역은 읽기 전용이기 떄문에 스레드 안전문제가 발생하지 않는다.

### 데이터 영역

전역변수가 저장되는 곳

모든 스레드는 전역 변수에 접근할 수 있다.

### 힙영역

스레드 간 공유 리소스

### 스택 영역

스레드 여러 개가 하나의 프로세스에 속서하는 경우, 하나의 스레드가 다른 스택 영역이라고 하더라도 모두 데이터를 읽고 쓸 수 있다.

## 스레드 전용 저장소

스레드 전용 저장소에 저장되는 변수는 다음과 같은 의미가 있다.

1. 이 영역에 저장된 변수는 모든 스레드에서 접근할 수 있다.
2. 모든 스레드가 동일한 변수에 접근하는 것처럼 보일 수 있지만, 사실 변수의 인스터는 각 스레드에 속한다. 따라서 하나의 스레드에서 변수 값을 변경해도 다른 스레드에 반영되지 않는다.

### 스레드 안전

어떤 코드가 주어졌을때 어떤 순서로 호출되든 간에 상고나없이 올바른 결과가 나온다면 이 코드를 스레드 안전이라고 말한다.

공유 리소스 : 단순한 변수일수도, 구조체처럼 데이터일수도.. 이런 리소스를 여러 리소스에서 읽고 쓸수 있어야 하고 이 조건을 만족해야한다.

## 코루틴

코루틴의 **Co**는 **Concurrency**라는 의미를 가지고있다. 즉, 동시성 프로그래밍 개념을 코틀린에 도입한 것이 코루틴 이라고 한다. 코루틴은 자신의 실행 상태를 저장할 수 있기 때문에 코루틴이 반환된 후에도 계속 호출이 가능하다. 자신의 이전 실행상태를 기억하고 있다 다시 실행될때 이전에 일시 중지 되었던 시점에서 계속 실행이 가능한 함수이다.

## 코루틴은 어떻게 구현될까?

스레드의 구현과 본질적으로 차이는 없다. 코루틴은 일시 중지 되거나 다시 시작될 수 있으며, 일시 중지 될 때의 상태 정보를 반드시 기록해야한다. 상태 정보에는

1. CPU 레지스터 정보
2. 함수 실행시 상태 정보

가 포함된다. 이는 스택 프레임에 저장된다.

그런데 프로세스 주소 공간의 스택 영역은 스레드를 위한 공간이다. 그렇다면 코루틴의 스택 프레임 정보는 어디에 저장해야 할까 ?

⇒ 힙 영역에 코루틴의 실행 시간 스택 정보를 저장하는 메모리를 요청할 수 있다.

스택 영역은 함수 스택 프레임을 보관하는데 사용된다. 단지 이 함수들이 코루틴이 아닌 일반 함수라는 차이가 있다.

# 느낀점

2장을 읽으면서 1장을 복습했다.

cpu는 하나의 일만 할수 있는데 어떻게 동시에 실행되는것처럼 보이는가? 에 대해 자세히 관심을 가져본적이 없다. 전환 빈도를 빠르게 만들어 동시에 실행되는것처럼 보이게 한다. 그와 동시에 동시성, 병령성에 대해서 정확하게 인지할수 있는 계기가 되었다.

운영체제는 코드의 재사용의 끝판왕. 운영체제가 존재함으로써 pc의 내부 구현 정확하게 알지 못해도 컴퓨터를 편리하게 사용할수 있구나.

프로세스에 대한 설명을 먼저 하고 그 후에 경량 프로세스, 스레드로 넘어가는 설명이 이해하기 쉬웠다. 프로세스 안에 스레드가 속해 있고 프로세스가 스레드보다 무거운 이유를 합리적이고 납득 가능하게 설명을 해준것같다.

자바스크립트로 개발하는 개발자가 코루틴을 이해하기 위해서는 async await, 프로미스, 제너레이터에 대입해서 공부해도 되는 걸까? 하는 고민이 들었다. 책을 읽은 후에 블로그 글을 좀 더 찾아보았다.

https://charming-kyu.tistory.com/58

[https://velog.io/@rohkorea86/Generator-함수를-이해해보자-이론편-왜-제네레이터-함수를-써야-하는가](https://velog.io/@rohkorea86/Generator-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EC%9E%90-%EC%9D%B4%EB%A1%A0%ED%8E%B8-%EC%99%9C-%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%8D%A8%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80)
