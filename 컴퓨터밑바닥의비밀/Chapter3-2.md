# 3.5 메모리를 할당할 때 저수준 계층에서 일어나는 일

숫자가 작을수록 특권이 커진다.

사용자 상태 / 커널 상태

## 3.5.2 커널 상태와 사용자 상태

커널 상태 : CPU가 운영체제의 코드를 실행할때

모든 기계 명령어를 실행할 수 있고, 모든 주소 공간에 접속할 수 있고, 제한 없이 하드웨어에 접근할 수 있다.

## 3.5.3 포털: 시스템 호출

운영체는 일반적인 프로그래머를 위해 특정한 ‘비밀코드’를 남겨두었다. 이걸 통해 **운영체제에 서비스를 요청**할 수 있는데 이것을 **시스템 호출**이라고 한다. 이 시스템 호출을 이용하여 운영체제가 파일의 읽기,쓰기, 네트워크 데이터 통신 같은 작업을 응용 프로그램 대신 처리해준다.

이런 시스템 호출은 모두 별도의 장소에 담겨있다.

## 3.5.4 표준 라이브러리: 시스템의 차이를 감춘다

![계층구조](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/5c3d7cbf-8de3-4bab-92b6-95ad7726a580/Untitled.png)

계층구조

3.4절에서 설명했던 malloc 같은 메모리 할당자는 사실 운영체제의 일부분이 아니라 표준 라이브러리의 일부로 구현되어있다.

### 3.5.5 힙 영역의 메모리가 부족할 때

**메모리 할당자 안의 여유 메모리 조각이 부족해지면 어떻게 해야할까 ?**

malloc은 메모리가 부족해지면 운영체제에 메모리를 요청해야한다. 리눅스의 모든 프로세스에는 brk변수가 있다. brk 변수는 브레이크를 의미하며, 힙 영역의 최상단을 가리킨다. brk변수 값을 위로 이동해서 힙 영역을 확장하려면 시스템 호출이 필요하다.

### 3.5.6 운영체제의 메모리 요청하기: brk (커널 상태에 놓여있음)

brk 를 호출을 이용하여 조절하는 방식으로 힙 영역 크기를 늘리거나 줄일 수 있다.

### 3.5.7 빙산의 아래: 가상 메모리가 최종 보스다

우리가 알고있는 빙산의 모습 : malloc에 메모리를 요청하고, 메모리가 부족할 때 운영체제의 힙 영역에 확장을 요청하며, 이후 malloc이 다시 여유 메모리 조각을 찾아 사용자에게 반환.

힙 영역을 포함한 전체 프로세스 주소 공간은 모두 실제 물리 메모리가 아니다. 프로세스 입장에서 사용하는 메모리는 모두 가상이다.

실제 할당한 메모리가 사용되는 순간에 물리 메모리를 할당하게 된다. 이때 가상 메모리가 아직 물리 메모리와 연결되어 있지 않으면 페이지 누락 오류가 발생할 수 있다. 이 오류를 감지하면 사상관계를 다시 설정하며 이것으로 실제 물리 메모리가 할당된다.

### 3.5.8 메모리 할당의 전체 이야기

malloc을 호출하면

1. 여유 메모리 조각을 검색, 적절한 크기를 찾으면 이를 할당
2. 찾지 못하면 brk로 힙영역 확장, 더 많은 여유 메모리 얻음
3. brk호출하면 커널상태 전환, 힙영역 확장작업 시장, 가상 메모리임
4. brk 종료되면 malloc으로 제어권 돌아감, 사용자 상태로 전환, 적절한 메모리 조각 반환
5. 다음단계 실행..

# 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까 ?

![malloc은 표준 라이브러리 계층, 메모리 풀은 응용프로그램의 일부이다.](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/cc2fc4f4-ec6e-49e9-8ea3-109b12f2d7b2/Untitled.png)

malloc은 표준 라이브러리 계층, 메모리 풀은 응용프로그램의 일부이다.

메모리 풀 기술은 특정 상황에서만 적용 가능하기 때문에 범용성이 매우 떨어진다.

## 3.6.2 메모리 풀 기술의 원리

한번에 큰 메모리 조각을 요청하고 그 위에 자체적으로 메모리 할당과 해제를 관리하는 방식으로, 표준 라이브러리와 운영체제를 우회한다. 또 서버에서 사용자 요청을 처리할 때 마다 여러 종류의 객체를 생성해야할떄마다 이런 객체를 미리 생상해두는 것이 가능하다.

## 3.6.3 초간만 메모리 풀 구현하기

1. **서버 프로그래밍**

미리 커다란 영역을 할당하고, 그 수량을 실제 상황에 따라 직접 결정할 수 있다. 사용할떄마다 하나씩 꺼내쓰면 끝.

아주 간단. 물론 특정 데이터 구조만 할당할 수 있다는 한계가 존재.

1. **서로 크기가 다른 메모리 요청을 지원하는 서버 프로그래밍**

모든 메모리 조각을 연결 리스트로 연결하고 포인터를 사용하여 현재 여유 메모리 조각의 위치를 기록할 수 있다. 메모리가 부족하면 malloc에 새로운 메모리 조각을 요청하고, 이때 새로운 조각의 크기는 이전 메모리 조각 크기의 두배이다.

## 3.6.5 메모리 풀의 스레드 안전 문제

잠금을 추가하면 성능 문제가 따라올 수 있으므로, 각 스레드마다 메모리 풀을 유지하며 스레드 간 경쟁 문제를 근본적으로 해결하면 좋다. 각 스레드에 대한 메모리 풀을 유지하는데에는 스레드 전용 저장소가 유용하게 쓰인다.

![이렇게 하면 각 스레드가 자신에게 속한 스레드 풀만 사용할 수 있다.](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/1f8762ee-f833-40b7-bb97-5e09e44cc7aa/Untitled.png)

이렇게 하면 각 스레드가 자신에게 속한 스레드 풀만 사용할 수 있다.

### 스레드 전용 저장소를 사용하면 생기는 문제

스레드 A가 메모리 조각을 요청했지만 그 수명 주기가 스레드 A자체를 넘어서는 상황.

A의 실행이 완료된 후에도 다른 스레드에서 해당 메모리를 계속 사용한다면, 해당 메모리는 A에 속해있지만 다른 메모리에서 해제해야 하는 상황이 생긴다.

## 3.7 대표적인 메모리 관련 버그

### 3.7.1 지역변수의 포인터 반환

```jsx

int* func(){
    int a =2;
    return &a;
}


void main(){
    int* p = func();
    *p = 20;
}
```

지역변수 a는 스택 프레임에 위치하며 func 함수의 실행이 끝나면 해당 스택프레임이 사라진다. main 함수가 func 함수를 호출한 후 얻는 포인터는 이미 없는 변수를 가리키게 된다.

### 3.7.2 포인터 연산의 잘못된 이해

```jsx

int sum(int *arr , int len){
    int sum = 0;
    for (int i = 0; i < len; i++)
    {
        sum +=*arr;
        arr += sizeof(int);
    }
    return sum;
}
```

앞의 코드는 포인터 연산을 잘못 이해하고 있다.

포인터 연산에서 1을 더하는 것은 1바이트만큼 이동하는 것이 아니라 **단위 한 개만큼 이동**하는 것을 의미한다. 단위 한개는 포**인터가 가리키는 데이터의 형식의 크기에 해당**한다.

즉, `sizeof(int)`는 `int` 형식의 크기를 바이트 단위로 반환하는 연산자이다. 대부분의 시스템에서 `sizeof(int)`는 4바이트일 것, (32비트 시스템 기준). 따라서 `arr += sizeof(int);`는 `arr` 포인터를 `int` 형식의 크기(보통 4바이트)만큼 이동시키는 것을 의미한다.

**원래 의도 :** 배열의 다음 요소를 가리키기 위해 포인터를 1개의 `int` 단위만큼 이동시키려고 한 것

**설명 요약** : sizeof 은 4바이트를 이동한다.. 우리가 아는 증감 연산자가 아니다.

### 3.7.3 문제 있는 포인터 역참조하기

```jsx
int a;
scanf("%d", a);
```

`scanf` 함수는 a값을 주소로 취급하기 때문에 표준 입력에서 가져온 데이터를 해당 주소에 쓴다.

앞의 코드에서 지역 변수 a값이 고정되어 있지 않으므로 상황에 따라 다음과 같은 여러가지 결과를 가져온다.

![결론: 코드영역빼고 다 불안불안함](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/0d7cd966-9ec8-4216-be35-c0ac84fb4784/Untitled.png)

결론: 코드영역빼고 다 불안불안함

1. a 값이 **코드 영역이나 기타 읽기 전용 영역을 가리키는 포인터 값**으로 해석되면 운영체제는 이 프로세스를 강제종료시킨다.
2. a의 값이 **스택 영역을 가리키는 포인터 값**으로 해석되었다면 ………………위로의 말씀을
   1. 다른 함수의 스택 프레임이 파괴된다.
3. a의 값이 **힙 영역 또는 데이터 영역을 가리키는 포인터**로 해석되었다면 …………또 위로의 말씀을.
   1. 프로그램이 동적으로 할당한 메모리가 파괴된다.

### 3.7.4 문제 있는 포인터 역참조하기

```jsx
void add(){

int* a = (int*)malloc(sizeof(int));
*a +=10

}
```

**malloc 을 호출할 때**

1. malloc이 자체적으로 충분한 메모리를 유지하고 있다면 malloc은 여유 메모리 조각에서 반환할 주소를 찾는다. 이 메모리는 사용됐을 수도, → 해당 경우 이전에 사용한 정보가 남아있을수도 있으니 0이 아님.
2. malloc은 자체적으로 유지하고 있는 메모리가 충분하지 않다면 brk 같은 시스템 호출로 운영체제 메모리를 요청한다. 메모리가 실제로 사용될때 페이지 누락 인터럽트가 발생하며 , 운영체제가 실제 물리 메모리를 할당하기 때문에 이 경우 0 으로 초기화 될 수 있음.

### 3.7.5 이미 해제된 메모리 참조하기

### 3.7.6 배열 첨자는 0부터 시작한다

```jsx
void int(int n){
int* arr = (int*)malloc(n * sizeof(int));
   for (int i = 0; i <= len; i++)
    {
       arr[i] = i
    }
}
```

### 3.7.7 스택넘침

### 3.7.8 메모리 누수

메모리 누수는 자동 가비지컬렉터를 지원하지 않는 언어에서는 흔하다.

# 3.8 왜 SSD는 메모리로 사용할 수 없을까 ?

- ssd 는 ddr 메모리 최대 대역폭보다 1/10 느리다.
- cpu가 파일의 특정 바이트에 직접 접근할 수 없다. ⇒ 바이트 단위 주소 지정이 지원되지 않는다.
- 메모리는 바이트 단위로, 디스크는 조각 단위로 주소가 지정된다.

CPU는 SSD에 저장된 데이터에 직접 접근할 수 있는 방법이 없기에 CPU는 SSD 또는 디스크에서 직접 프로그램을 실행할 수 없다.

### 3.8.2 가상 메모리의 제한

최신 운영 체제의 메모리 관리는 기본적으로 가상 메모리 기반이다.

### 3.8.3 SSD 사용 수명 문제

# 3.9 요약

거시적 수준에서 보는 메모리는 매우 복잡하다. 메모리는 함수 실행 시 정보를 저장하고, 함수의 호출과 반환이 되는 스택 영역이 있으며, 할당 요청된 메모리 수명 주기를 프로그래머가 직접 관리해야하는 힙 영역이 있다.

물리 메모리 위에 가상 메모리를 추상화하여 최신 운영체제가 각 프로세스에 메모리를 독점적으로 부여하는 것 처럼 만든다. 이것으로 프로그래머는 연속된 주소 공간에서 프로그래밍을 할 수 있게 되었고 이는 엄청난 편리함을 제공한다.
