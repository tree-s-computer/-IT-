## 2.5.5 콜백 함수의 정의

정보 관점 :

컴퓨터 관점 :

1. 정수,포인터,구조체,객체
2. 함수 같은 코드

### 처리 흐름을 하나의 작업으로 생각할 때

동기 호출 : 호출한 스레드에서 전체 작업이 처리된다.

비동기 호출 : 작업 처리가 두 부분으로 나뉜다.

1. 첫 번째 부분은 함수를 호출하는 스레드에서 처리된다.

1. 함수를 호출하는 스레드에서 처리되지 않고 다른 스레드, 프로세스, 또는 다른 시스템에서 처리된다.

콜백 함수의 본질 : 우리는 어떤 일을 해야 하는지 알지만, 이 일을 언제 하게 될지는 정확히 알 수 없다.

동기 콜백이 진행될때 아무것도 못하지만 비동기 프로그램은 아무런 문제 없이 프로그램을 실행할 수 있다.

비동기 콜백은 입출력에서 자주 볼 수 있다. ⇒ ?

웹 서비스처럼 동시성이 높은 시나리오네 적합하다.

### 2.5.7 비동기 콜백의 문제 : 콜백지옥

동기 : 종속적, 연관된, 기다림

비동기: 비종속적, 무관한, 기다릴 필요 없는, 동시 발생

## 동기 호출

```jsx
funcA(){
//funcB 함수가 완료될 때 까지 기다린다.
funcB();
//funcB 함수는 프로세스를 반환하고 계속 진행한다.
}
```

funcA 함수가 funcB 함수를 호출하면, funcB 함수 실행이 완료될 때 까지 funcA함수의 나머지 코드는 실행되지 않는다.

## 비교적 특수한 상황, 입출력 작업

```jsx
read(file, buf); // 여기에서 실행이 일시 중지된다.
//파일 읽기가 완료될 깨까지 기다렸다가 계속 실행한다.
```

최하단 계층은 실제로 시스템호출(system call) 로 운영체제에 요청을 보낸다. 이때 운영체제는 파일 읽기 작업을 위해 호출 스레드를 일시중지 시키고, 커널이 디스크 내용을 읽어 오면 일시 중지되었던 스레드가 다시 깨어난다. 이것이 바로 **블로킹 입출력**이다.

호출자와 파일을 읽는 코드는 다른 스레드에서 실행된다. 동기 호출은 호출자와 수신자가 같은 스레드에서 실행중인지 여부와는 관련이 없다.

## 비동기 호출

비동기 호출은 디스크 파일 읽고 쓰기, 네트워크 데이터 송수신, 데이터베이스 작업처럼 시간이 많이 걸리는 입출력 작업을 백그라운드 형태로 실행한다.

read 함수가 비동기 호출되면 파일 읽기 작업이 완료되지 않은 상태에서도 read함수는 즉시 반환될 수 있다.

```jsx
read(file, buff);
//read 함수는 즉시 반환
//이후 내용의 실행으 를로킹 하지 않는다.
```

호출자의 이후 작업은 파일 읽기 작업과 동시에 진행되기 때문에 이것이 바로 비동기의 높은 효율성을 가져온다.

### 비동기 호출에서는 파일 읽기 작업이 언제 완료됐는지 어떻게 알 수 있을까?

이에 대한 처리는 두 가지 상황이 있을 수 있다.

1. 호출자가 실행 결과를 전혀 신경쓰지 않을 때
2. 호출자가 실행 결과를 반드시 알아야 할 때

```jsx
 void hanlder(void* buf){
... // 파일 내용 처리 중
 }

 read(buf, handler)
```

계속해서 파일을 읽고, 작업이 완료되면 전달된 함수를 사용하여 파일을 처리해 주세요.

이와 같은 파일 내용은 호출자 스레드가 아닌 콜백 함수가 실행되는 다른 스레드 또는 프로세스 등에서 처리한다.

소프트웨어 조직 구조 관점에서 볼 때,

이 작업은 데이터베이스 스레드에서 해야 할 작업이 아니다.

**첫 번째 상황 : 주 스레드가 데이터 베이스 처리 결과를 전혀 신경쓰지 않을때**

주 스레드가 사용자 요청을 처리하는 작업과 데이터 베이스 스레드가 데이터 베이스를 처리하는 작업을 동시에 진행할 수 있다. 이것이 바로 비동기가 가지는 높은 효율성이다.

⇒ 자바스크립트가 비동기 언어인 이유는 스레드가 하나이기 때문에 어쩔 수 없이 비동기로 설계된다고 생각했는데 그게 아니었던건가..?

두 번째 상황 : 주 스레드가 데이터베이스 작업 결과에 관심을 가질 때

비동기 호출이 반드시 동기 호출보다 효율적인 것은 아니다.

# 2.7 블로킹과 논블로킹

동기는 A와 B라는 두 대상이 강하게 결합된 것을 의미한다. A가 작업 B에 의존하는 경우, 이런 의존 관계에 의해 A와 B는 동기이다.

블록킹 방식: 함수 A가 B를 호출할 때, 함수 B를 호출함과 동시에 운영 체제 함수A가 실행 중인 스레드나 프로세스를 일시 중지시킨다면 함수 B에 의한 우누영 체제가 함수 A가 실행 중인 스레드나 프로세스를 일시 중지 시키는것

논블록킹: 안그런거

### 블록킹의 핵심 문제 : 입출력

CPU 제어권을 상실했다 되찾는 시간 동안 스레드나 프로세스는 블로킹되어 일시 중지된다.

운영체제는 CPU의 리소스를 최대한 활용할 수 있도록 각 스레드 간에 CPU 사용 시간을 효율적으로 할당해야하는데, 이것이 바로 블로킹 입출력 방식이 필요한 핵심적인 이유이다.

이러한 입출력 작업이 너무 느리다 보면 관련 함수를 직접 호출하면 스레드 또느 프로세스가 블로킹이 되는 일이 생긴다.

### 논블로킹과 비동기 입출력

데이터를 수신하는 함수인 recv가 논블로킹이면, 이 함수를 호출할 때 운영 체제는 스레드를 일시 중지 시키는 대신 recv함수를 즉시 반환한다. 이후 호출 스레드는 자신의 작업을 계속 진행하며 데이터 수신 작업은 커널이 처리한다.

데이터를 언제 수신했는지 어떻게 알 수 있는가 ?

1. recv함수 외에 결과를 확인하는 함수를 함께 제공하고, 해당 함수를 함께 호출한다.
2. 데이터가 수신되면 스레드에 메세지나 신호 등을 전송하는 알림 작동 방식을 사용한다.
3. 콜백 함수에 담아 매개변수로 전달하기

## 2.7.5 동기와 블로킹

동기는 블로킹과 다소 유사하다.

동기호출은 반드시 블로킹이 아니다.

블로킹 호출은 모두 확실하 동기 호출이다.

```jsx
int sum(int a, int b){
return a + b
}

void funcA(
sum(1,1)
)
```

## 2.7.6 비동기와 논블로킹

프로세스,스레드,코루틴

-

동기,비동기,블로킹,논블로킹

=

고성능 서버

# 궁금증

- i/o 작업은 정확히 무엇일까?
- db작업도 i/o작업에 포함이 되는 것일까 ?
- 동기적/비동기적 처리에 대한 차이점이 존재하는데 언어마다 설계가 다른건가 ? 그럼 동기적으로 작동하는 언어도 있는가..?
- 데이터베이스 스레드란 무엇인가
- 주 스레드가 사용자 요청을 처리하는 작업과 데이터 베이스 스레드가 데이터 베이스를 처리하는 작업을 동시에 진행할 수 있다. 이것이 바로 비동기가 가지는 높은 효율성이다.

⇒ 자바스크립트가 비동기 언어인 이유는 스레드가 하나이기 때문에 어쩔 수 없이 비동기로 설계된다고 생각했는

데 그게 아니었던건가..?

- 알림작동방식이란 무엇일까?>

변수는 결국 주소를 부르기 쉬운 별칭으로 칭하는 것으로부터 시작 됐다.

a 변수 뒤에 뜻

1. 값을 (1) 나타낸다.
2. 메모리 주소(3)에 저장에 저장된다.

**포인터:** 변수의 가뵷 뿐만 아니라 메모리 주소까지 저장할수 았게 되는 것

포인터는 주소 차제라고 언급되는 것은 사실 어셈블리어 수준에서만 적용 되는 이야기일뿐.. **포인터는 하나의 변수에 불과하다.** 포인터는 메모리 주소를 더 높은 수준으로 추상화한것.

우리는 모든 함수에는 각자만의 스택 프레임이 있으며 이 안에는 반환주소, 지역변수, 매개변수, 레지스터를 비롯한 정보가 저장된다.

### 3.4.1. 힙영역

직접할당하고 해제하는 동적 할당

### 3.4.2. malloc 메모리 할당자 직접 구현하기

malloc 메모리 할당자 : c언어에서 **메모리의 동적 할당과 해제 요쳥**은 모두 전문적으로 힙 영역에 메모리를 할당하고 해제하는 작은 프로그램

232p

### 3.4.3 여유 메모리 조각 관리하기

사용 가능한 메모리 조각을 관리하는 작업의 특성상 어떤 영역이 사용 가능한 메모리고 어떤 영역이 이미 할당된 메모리인지 구분하는 방법이 필요하다.

# 감상평

옛날에 js 가비지 컬렉터가 어떻게 동작하는지 어느 타이밍에 수거되는지 어디에 저장되고 어디에 사라지는지 확인하고 싶었는데 그때는 js는 메모리 주소를 직접적으로 알수 없다는 사실을 몰라서 메모리 주소를 찍어보려고 이것저것 검색했던 기억이 난다. (빨리 알았더라면…)

이번 파트를 읽고 메모리주소/포인터/참조 에 대한 개념이 잡혔다. 세개 다 똑같은 말인줄 알았는데 사실은 조금씩 다른 개념이었던것.

# 궁금증

### 레지스터는 CPU의 일부분, 이건 물리메모리일까 논리 메모리일까?

레지스터는 CPU의 일부분으로, 물리적인 하드웨어에 해당합니다. 레지스터는 CPU 내부에 위치한 고속의 작은 메모리 공간으로, 주로 연산을 수행할 때 필요한 데이터나 명령어를 일시적으로 저장하는 데 사용됩니다.

### 8비트로 만들수 있는 조합은 고작 256개뿐, 그래서 더 많은 숫자를 표현하기 위해 인트는 보통 4바이트다. 그럼 4바이트로 모든 수를 표현할수 있을까? 4바이트가 넘어가는건 없을까?

대부분의 숫자는 표현이 가능하다고 한다.

### 왜 1바이트는 8비트일까?

1. **역사적 이유**: 초기 컴퓨터의 설계자들은 한 바이트에 몇 비트를 포함할지 결정해야 했습니다. 8비트가 선택된 이유 중 하나는 8비트가 2의 거듭제곱이기 때문에 처리와 연산이 효율적이기 때문입니다. 또한, 8비트는 256개의 고유한 값을 표현할 수 있어, 알파벳과 숫자, 특수 문자를 포함하는 ASCII 문자 집합을 표현하기에 충분했습니다.
2. **표준화**: 8비트 바이트가 채택된 후, 이는 표준화되었습니다. IBM의 System/360(1960년대)은 8비트 바이트를 사용했으며, 이는 다른 시스템에도 널리 채택되면서 표준으로 자리잡게 되었습니다.
