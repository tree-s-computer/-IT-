# 트랜지스터

이 기능은 간단하다. 단자 한쪽에 전류가 흐르면 나머지 단자 두개에 전류가 흐르게 할 수도 있고 흐르지 못하게 할 수도 있다.

## 4.1.2 논리곱, 논리합, 논리부정

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/8c7d45ef-e401-4520-a927-284e3b53ed25/Untitled.png)

세가지 회로

- **[논리곱 게이트]** 스위치 두개가 동시에 켜질때만 전류가 흐르고 등이 켜짐
- **[논리합 게이트]** 두 스위치 중 둘 중 하나라도 켜져있으면 전류가 흐를 수 있고 등이 켜짐
- **[논리부정 게이트] 스**위치를 닫으면 전류가 흘러 등이 켜짐, 열면 전류가 흐르지 않고 등이 꺼짐

## 4.1.3 도는 하나를 낳고, 하나는 둘을 낳고,. …

(어떤것이 존재하면 모든 것은 존재할수 있다.(?))

이 세개로 모든 함수를 표현할수 있다. 이것을 논리적 완전성이라고 한다.

## 4.1.4 연산 능력은 어디에서 나올까?

[1 **자리 올림수** `자리올림數`](https://wordrow.kr/%EC%9E%90%EC%84%B8%ED%95%9C-%EC%9D%98%EB%AF%B8/%EC%9E%90%EB%A6%AC%20%EC%98%AC%EB%A6%BC%EC%88%98/1/) : 컴퓨터의 가산 논리 회로에서 이진수 값을 덧셈한 결과, 어떤 자리의 숫자의 합이 그 자리에서 나타낼 수 있는 가장 큰 수를 넘어 다음 상위 자리로 보내지는 수.

**자리올림수:** 두 입력값 모두 1일때만 1임

**배타적 논리합 :** 두 입력값이 서로 다르면 결과가 1, 서로 같으면 결과가 0

**ALU:** CPU 에 전문적으로 계산을 담당하는 모듈, 산술 논리 장치

## 4.1.5 신기한 기억 능력

설계한 조합 회로는 연산 능력은 있지만 저장할 방법이 없어 입력을 기반으로 출력을 내보낼뿐이다.

![부정 논리곱 게이트 두개를 조합한것](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/8359d5af-034c-4e08-8f8a-e22eddeb0810/Untitled.png)

부정 논리곱 게이트 두개를 조합한것

.. 부정 논리곱 게이트 또한한 **논리곱 게이트, 논리부정 게이트**를 조합한 것

**S단자와 R단자에 1이 입력되는 한** 이 회로는 다음과 같이 두가지 상태를 가진다.

단자 a가 1이면 B=0, A=1, b=0

단자 a가 0이면 B=1, A=0, b=1

**S단자를 0으로 설정하면** (R단자는 여전히 1) 회로의 출력값인 단자 a는 항상 1이 된다.

반면 **R을 0으로 설정하면** (S단자는 여전히1) 회로의 출력값인 단자 a는 항상 0이 된다.

## 4.1.6 레지스터와 메모리의 탄생

더 많은 정보를 저장하고 주소를 지정하기 위해 더 복잡한 회로를 계속해서 구축해야한다.

## 4.1.7 하드웨어 아니면 소프트웨어 ? 범용장치

세상에 다양한 레시피가 있듯이 모든 연산 논리를 반드시 회로같은 하드웨어로 구현할 필요는 없다. 하드웨어는 변하지 않지만 소프트웨어는 변할수 있기에 변하지 않는 하드웨어에 서로 다른 소프트웨어를 제공하면 하드웨어가 완전히 새로운 기능을 구현할수 있다.

## 4.1.8 , 4.1.9 명령어 집합

명렁어는 16비트로 구성 , 처음 4비트는 CPU에 수행할 작업을 알려줌

R6과 R2를 더한후 레지스터 R6에 기록

시스템 계층 관점에서 보면 명령어 집합은 소프트웨어와 하드웨어가 만나는 곳이다. 소프트웨어와 하드웨어가 만나는 장소이자 서로 통신하는 인터페이스

기계 명령어 하나가 할 수 있는 일은 사실 매우 간단하다. CPU 는 기계 명령어만 이해할 수 있으므로 고급 프로그래밍 언어를 기계 명령어로 변환하는 도구가 필요하고, 바로 이 도구가 컴파일러다.

회로에는 많은 부분으로 구성되어있다. 일부는 **데이터를 계산하는데 사용되고 일부는 정보를 저장**하는데 사용된다. 각 부분 회로와 함께 작업할 수 있도록 조정하거나 동기화하려면 어떻게 해야할까 ?

CPU 에서 지휘자 역할을 맡고 있는 것이 **클럭신호**이다. (**CPU의 속도를 나타내는 단위**)

## 4.1.11 CPU 탄생

산술 논리 장치, 레지스터, 클럭 이를 한데 묶은 것을 일컬어 중앙처리장치 즉 CPU또는 프로세서라고 한다.

---

코맨드 + 스페이스 활성상태보기

## 4.2.1

프로세스도 운영체제의 대기열로 관리된다. 운영체제도 프로세스에 우선 순위를 할당하고, 우선순위에 따라 스케줄러가 스케줄링을 할수 있도록 대기열에 프로세스를 넣는다. 프로세스 스케줄링은 운영 체제가 구현해야 하는 핵심 기능 중 하나이다.

## 4.2.4

스케줄링 가능한 프로세스가 없을 때 스케줄러는 유휴 프로세스를 꺼내서 실행함

CPU 설계자는 일찍이 시스템에 유휴 상태가 존재할 가능성을 고려했기 때문이 하나의 기계 명령어를 설계했다. 이 기계 명령어가 바로 정지를 의미하는 halt 명령어다. halt는 특권 명령어라 CPU 로만 실행될 수 있다.

마지막으로 프로세스 일시중지와 halt 명령어를 혼동하지 않도록 유의 바란다.

sleep 같은 함수를 호출하면 함수를 호출한 프로세스만 일시중지된다.

이때 다른 프로세스가 여전히 실행 상태라면 CPU는 유휴 상태로 진입할 수 없다.

CPU 가 halt 명령어를 실행한다는 것은 **시스템 내 더이상 실행할 준비가 완료된 프로세스가 없다는 것.**

스케줄링 가능한 프로세스가 더 이상 존재하지 않으면 스케줄러가 유휴 프로세스를 실행하는데, 이것으로 순환 구조에서 계속 halt 명령어가 실행된다. halt 명령어로 CPU 는 저전력 상태로 진입하기 시작한다.

## 4.2.6 무한 순환 탈출

while.. 어떻게 빠져나오나 ?

컴퓨터 운영 체제는 일정 시간마다 타이머 인터럽트를 생성하고, CPU는 인터럽트 신호를 감지하고,운영 체제 내부의 인터럽트 처리 프로그램을 실행한다. 상응하는 인터럽트 처리 함수에서는 프로세스가 실행될 준비가 되었는지 판단한다.

**준비가 되었다면?** 중단되었던 프로세스를 계속 실행한다.

**준비가 되어있지 않았다면?** 프로세스를 일시 중지시키고, 스케줄러는 준비 완료 상태인 다른 프로세스를 스케줄링한다.

프로그램에 무한 순환이 있더라도 운영체제는 인터럽트를 통해 제어할수 있다.

## 4.3

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/ecd40dde-bdf8-47f0-8e6c-1d3326792639/Untitled.png)

### 부호있는 정수

[부호-크기 표현] 최상이 비트를 1로만 바꾸기만 함. 아주 간단하고 인간의 사고방식에 가까움.

[1의 보수] 모든 비트를 반전시킴

## 4.4 CPU 가 if문을 만났을때

## 4.5 CPU 코어 수와 스레드 수 사이의 관계

단일 코어/ 멀티코어가 스레드 갯수와 관련이 있다고 생각하나?⇒ 아님

CPU는 하드웨어. 스레드는 소프드웨어개념.→ 더 정확하게는 실행 흐름이자 작업.

따라서 단일 코어 시스템에서도 얼마든지 많은 스레드를 생성할 수 있다.

물론 메모리가 충분하고 운영체제에 제한이 없어야 한다.

CPU 는 근본적으로 자신이 실행하는 명령어가 어떤 스레드에 속하는지 이해하지 못한다. 이를 이해해야 하는 것은 운영체제 이다. CPU 가 해야 하는 일은 PC 레지스터 주소에 따라 메모리에서 기계 명령어를 꺼내 실행하는 것 뿐이다.

작업 하나를 여러 개로 분할한 후 각각의 하위 작업을 별도의 스레드에 배치하면 운영체제에서 이를 스케줄링하고 실행할 수 있으므로 동시에 여러 작업을 실행할 수 있다.

사용자 요청도 하나의 작업,

디스크를 읽고 쓰는 것도 하나의 작업에 해당한다.

예를들어 사용자 인터페이스 요소 뒤에서 대량의 계산을 수행해야 한다고 한다. 계산 작업을 별도의 스레드에 넣어 계산을 수행하는 동안 사용자 인터페이스가 멈추는 것을 방지할 수 있다. 이외에도 처리해야 하는 작업이 블로킹 입출력과 관련이 되었을때 블로킹 호출이 실행되면 운영체제가 전체 스레드를 일시 중지하므로 호출 되에 있는 코드도 실행되지 않는다.

# 4.6 CPU 진화론(상): 복잡 명령어 집합의 탄생

## 4.6.1 프로그래머의 눈에 보이는 CPU

간단한 프로그램이든 복잡한 프로그램이든 결국 컴파일러로 하나하나 간단한 기계 명령어로 변환한다. 하나는 많은 명령어를 포함하고, 하나는 적은 수의 명령어를 포함하고 있을 뿐이다. 이런 명령어는 실행 파일에 저장되며 프로그램이 실행되면 메모리에 적재된다. **CPU는 단순하게 메모리에서 명령어를 읽어 실행하기만 하면 된다.**

## 4.6.2 CPU의 능력 범위: 명령어 집합

CPU의 능력 범위

- 덧셈 가능
- 메모리에서 레지스터로 데이터 이동시킬수있음
- 점프 가능
- 크기 비교 가능

우리가 명령어 집합에서 명령어를 하나 찾아 CPU로 보내면 CPU는 해당 명령어가 지시하는 작업을 실행한다.

예를들면 ADD명령어가 주어지면 CPU는 덧셈 계산을 수행한다. 명령어 집합은 당연히 프로그래머가 프로그래밍에 사용한다. 최초의 프로그램은 CPU에 대응하느 어셈블리어로 작성되었다.

### 집합 컴퓨터

첫 번째 명령 집합 유형이자 처음으로 탄생했던 명령어 집합이다. 오늘날 데스크톱 PC와 서버에 공통으로 사용되는 x86 구조는 복잡 명령어 집합에 기초를 두고있다. 이런 x86프로세서를 생산하는 제조업체는 우리에게 친숙한 인텔과 AMD다.

인텔:  [미국](https://namu.wiki/w/%EB%AF%B8%EA%B5%AD)의 [종합반도체사](https://namu.wiki/w/%EC%A2%85%ED%95%A9%EB%B0%98%EB%8F%84%EC%B2%B4%EC%82%AC)

AMD:[미국](https://namu.wiki/w/%EB%AF%B8%EA%B5%AD)의 [반도체](https://namu.wiki/w/%EB%B0%98%EB%8F%84%EC%B2%B4) 기업으로 [실리콘밸리](https://namu.wiki/w/%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC)의 1세대 주요 기업 중 하나였다. 각각 [x86](https://namu.wiki/w/x86) 기반의 소비자용 [CPU](https://namu.wiki/w/CPU) 분야에서는 [인텔](https://namu.wiki/w/%EC%9D%B8%ED%85%94), 외장 [GPU](https://namu.wiki/w/GPU) 분야에서는 [NVIDIA](https://namu.wiki/w/NVIDIA)와 경쟁하고 있는 유일한 사업자이다.

X86:[인텔](https://namu.wiki/w/%EC%9D%B8%ED%85%94)이 **1978년**에 출시한 [**인텔 8086**](https://namu.wiki/w/%EC%9D%B8%ED%85%94%208086)에 적용된 아키텍처이자, 그 호환 프로세서와 후속작을 이르는 말이다. 1978년에 출시되어 40년이 지난 굉장히 오래된 아키텍처이지만, 이후에 출시된 프로세서들은 8086의 명령어 세트를 기반으로 하여 확장된 것이다. 이러한 이유로 **32비트 CPU는 x32라고 표기하지 않고 x86이라고 표기한다.**

## 4.6.3

1970년까지는 컴파일러가 아직 성숙하지 못해서 컴파일러를 신뢰하지 않는 사람도 많았다. 그 시기의 대부분의 프로그램은 직접 어셈블리어로 작성되었기 때문에 일반적으로 명령어 집합이 더욱 더 풍부해야하며 **명령어 자체 기능도 더 강력해야 한다고 여겼다.**

현재 컴파일러가 발전해서 어셈블리어의 존재를 거의 인지하지 못하지만 안타까워할 일은 아니다. 고급 언어 프로그래밍의 효율성은 이미 어셈블리어가 범접할 수 없는 곳에 있다.

이 시기 대부분의 프로그램을 어셈블리어로 작성되었고, **자주 사용하는 작업마다 대응하는 특정 명령어가 있는 것이 가장 합리적**이었으며, 결국 모든 사람이 어셈블리어로 직접 프로그램을 작성했기 때문에 이 방식은 매우 편리하다 여겨졌다.

### 의미상 간격

당시에는 함수 호출, 순한 제어, 복잡한 주소 지정 패턴, 데이터 구조, 배열 접근 등 고급 언어의 개념과 이에 직접 대응하는 기계 명령어가 있어야 한다고 생각했다. 이렇게 **기계 명령어와 고급 언어 개념간 차이를 줄여야만** 더 적은 코드로 더 많은 작업을 할 수 있었기 때문.

어셈블리어로 코드를 작성할 때 편리하다는 점 외에도 고려해야할 또 다른 사항은 저장 공간의 효율적인 사용에 대한 것이다.

## 4.6.4 코드도 저장 공간을 차지한다

오늘날의 컴퓨너틑 기본적으로 **폰 노이만 구조**를 따른다.

“저장 개념에서 프로그램과 프로그램이 사용하는 데이터에 어떠한 차이도 없어야 한며, 모든 컴퓨터의 저장 장치 안에 저장될 수 있어야 한다.”

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/6784d913-3574-4ad2-9c48-9ad290b967e3/Untitled.png)

(폰노이만 구조에서는) 실행 파일은 **기계 명령어와 데이터를 모두 포함**하고 있다는 것을 알 수 있다.

또 프로그래머가 작성한 코드는 디스크 저장 공간을 차지하며 실행 시에는 메모리에 적재되므로 메모리 저장 공간을 차지한다.

작은 메모리에 더 많은 프로그램을 적재하려면 기계명령어를 매우 세밀하게 설계해 프로그램이 차지하는 저장공간을 줄여야한다.

1. 하나의 기계명령어로 많은 작업을 완료할 수 있으므로
2. 고정되어있지 않은 명령어, 가변적
3. 밀도를 높여 인코딩

## 4.6.5 필연적인 복잡 명령어 집합의 탄생

명령어를 사용한 편리한 프로그램을 작성하고 코드의 저장 공간을 절약해야 했기에 복잡 명령어 집합을 설계해야 하는 필요성이 대두되었다. 복잡 명령어 집합을 탄생시켰다.

새로운 문제 :

이 시기 CPU 명령어 집합은 모두 직접 연결 방식이었다. 즉 명령어 인출, 명령어 해독, 실행 등 각 단계가 특정 조합 회로로 직접 제어된다. 명령어 실행하는데는 매우 효율적이지만 유연성은 매우 떨어져 명령어 집합의 변경에 대응하기 어렵다. 새로운 명령어를 추가하면 CPU설계와 디버깅 복잡도가 높아지며 특히 복잡 집합의 명령어는 길이가 고정되어있지 않아 복잡한 연산 등이 포함되면 문제가 더 악화될 수 있다.

문제 본질 : 하드웨어를 변경하는 것은 매우 번거롭고, 소프트웨어는 이와 다르게 쉽게 변경할 수 있음.

![여기서 사용되는 더 간단한 명령어가 바로 마이크로 코드이다. ](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/d0a669d4-f686-4f91-a064-502b98d5ec22/Untitled.png)

여기서 사용되는 더 간단한 명령어가 바로 마이크로 코드이다.

명령어에 포함된 연산을 더 간단한 명령어로 구성된 작은 프로그램으로 정의하고 이를 CPU에 저장하면, 모든 기계 명령어에 대응하여 전용 하드웨어 회로를 설계할 필요 없다. 즉 소프트웨어가 하드웨어를 대체하게 되는 것이다.

더 많은 명령어를 추가할 때, 주요 작업은 마이크로코드 수정에 집중되며 하드웨어 수정은 거의 필요 하지 않다.

## 4.6.6 마이크로코드 설계의 문제점

복잡 명령어 집합이 등장하면서 프로그래머는 어셈블리어로 프로그램을 더 쉽게 작성할 수 있게 되었고 저장공간의 효율도 높아졌다.복잡명령어 집합으로 발생하는 프로세서 설계의 복잡한 문제는 마이크로 코드로 단순화 할 수 있었다.

또다른 문제 : 버그..

마이크로 코드 버그 수정은 어렵고 마이크로 코드 설계는 트랜지스터를 매우 많이 소모한다.

트랜지스터:

# 4.7 CPU진화론(중) 축소 명령어 집합의 탄생

복잡 명령어 출현은 초기단계의 컴파일러, 저장장치의 용량 제한같은 객관적인 조건의 제한이었다

기술이 발전하고 메모리 용량이 늘어나고 가격이 급속도로 떨어졌다.

컴파일러 기술이 점점 발전하고 프로그래머도 점점 고급 언어로 프로그램을 작성하기 시작했다. 컴파일러에 의존하여 어셈블리어 명령어를 자동으로 생성했다.

복잡한 명령어를 간단한 명령어 여러개로 대체하면 안되는 이유가 뭘까 ?

## 4.7.2 축소 명령어 집합의 철학

### 1. 명령어 자체의 복합성

명령어 집합을 줄인다는 것은 명령어 집합의 명령어 갯수가 줄아든다는 단순한 의미가 아니다.

하나의 명령어당 들여야 하는 연산이 더 간단하다는 것을 의미한다.

먹는다: 먹을준비하고씻고어쩌구저쩌구

한입베어먹는거그자체

### 2. 컴파일러

컴파일러가 CPU에 대한 강력한 제어권을 갖는다.

복잡 명령어 집합에서 CPU는 마이크로코드같은 기계 명령어의 실행 세부사항을 컴파일러에 숨기므로 컴파일러는 아무것도 알 수 없다. 하지만 축소 명령어 집합은 CPU에 많은 세부사항을 컴파일러에 제공한다.

### 3. LOAD/STORE 구조

**복잡 명령어:** 데이터를 가져오고, 작업을 수행하고 해당 데이터를 메모리에 다시 쓰는 작업을 모두 할 수 있다. 단지 하나의 기계 명령어로 수행된다는것.

**축소 명령어 집합**에서 이것은 절대 불가능함 금기. **레지스터내 데이터만 처리할 수 있으며** 메모리 내 데이터는 직접 처리할 수 없다. 하지만 결국 데이터는 여전히 메모리 내에 저장되어있다.

LOAD/STORE 라는 전용 기계 명령어가 메모리의 읽고 쓰기를 책임진다.

다른 명령어들은 CPU내부의 레지스터만 처리할 수 있으며 메모리를 읽거나 쓸 수 없다.

## 4.7.3 복잡 명령어 집합과 축소 명령어 집합의 차이

![왼쪽은 CPU, CPU내부에 있는 것은 레지스터와 연산 장치인 ALU. 
오른쪽은 기계 명령어와 데이터를 저장하는 메모리.](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/d8885956-e8a7-47a6-a4b3-4198575a74e9/Untitled.png)

왼쪽은 CPU, CPU내부에 있는 것은 레지스터와 연산 장치인 ALU.
오른쪽은 기계 명령어와 데이터를 저장하는 메모리.

두 숫자가 각각 메모리 주소 A,B에 저장된다.

### 1. 복잡 명령어 집합의 경우

사상: 가능하면 적은 수의 기계 명령어고 **가능한 많은 작업**을 수행하라!

MULT A B

MULT는 복잡한 명령어

이 명령어에 엄청 많은 작업이 포함되어있음

고급 언어와 매우 유사함

### 2. 축소 명령어 집합의 경우

사상: 반대로 **간단한 명령어 여러개**를 사용하여 작업을 완료하라!

ㅇㅋ..잘게 쪼게느낌…?

## 4.7.4 명령어 파이프라인

축소 명령어 집합에서 생성된 명령어들 …

각 명령어가 매우 간단하여 실행시간이 모두 거의 동일하다. 이 경우 기계 명령어의 실행 효율을 높이는 방법을 사용할 수 있는데, 이 기술이 파이프라인 기술이다.

파이프라인 기술은 비록 기계 명령어 하나가 실행되는 시간을 단축해주지 않지만 **처리량을 늘릴 수 있다.**

복잡 명령어 집합에서는 명령어 사이에 비교적 차이가 크기에 실행 시간이 고르지 않다. 따라서 기계 명령어를 효율적으로 실행하기 위해 파이프라인 방식을 제대로 활용할 방법이 없다.

1세대 축소 명령어 집합 프로세서는 전체가 파이프라인 기반으로 설계되어 일반적으로 5단계 파이프라인 기준으로 명령어 하나가 1~2클럭 주기로 실행된다. 반면에 동시애 복잡 명령어 집합 프로세서는 5~10클럭 주기가 필요하다.

높은 클럭 주파수를 가지게 되어 축소 명령어 집합 구조의 CPU는 동일한 작업을 할때 복잡 명령어 구조보다 우수하다.

## 4.7.5 천하에 명성을 떨치다

1980년 후반대에는 축소 명령어 집합으로 설계된 CPU가 성능 면에서 기존 모든 전통적인 설계를 가볍게 진압했다.

# 4.8 CPU 진화론(하): 절체절명의 위기에서의 반격

# 4.9 CPU , 스택과 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리 통달하기

## 4.9.1 레지스터

CPU에 레지스터가 필요한 이유? ⇒ 속도 때문이다.

CPU가 레지스터 없이 전적으로 메모리에 의존한다면 계산속도는 매우 느려지게 될 것. 사실 레지스터와 메모리는 본질적으로 차이가 없다. 둘다 정보를 저장하는 데 사용된다. 단지 레지스터의 읽기와 쓰기 속도가 훨씬 빠르고 제조 비용도 훨씬 비싸기 때문에 용량에 한계가 있을 뿐. 따라서 어쩔 수 없이 **프로세스의 실행 시 정보를 모두 메모리에 저장**하고 **CPU가 사용할 때만 임시로 레지스터에 데이터를 보관**하는 것이다.

## 4.9.2 스택포인터

실행되는 모든 함수는 스택 프레임을 가진다. 스택 상단 정보는 스택 하단을 가리키는 **스택 포인터**에 저장된다. 이 포인터로 함수 호출 스택의 추적이 가능하다.

함수가 실행될 때 함수에 정의된 로컬 변수와 전달된 매개 변수등을 저장하는 독립적 메모리 공간 ⇒ **스택 프레임**

이외에도 **지금 어떤 명령어를 실행하고 있는지에 대한 정보**가 매우 중요한데, 이 정보는 **명령어 주소 레지스터**가 가지고 있다.

## 4.9.3 명령어 주소 레지스터

명령어 주소 레지스터는 이름이 여러개다.

대다수 프로그래머 ⇒ 프로그램 카운터, PC

x86 ⇒ 명령어 포인터 ⇒ IP

프로그램이 실행되면 첫 번째로 실행할 기계 명령어의 주소가 PC레지스터에 저장되며 CPU는 이 PC레지스터에 저장되어 있는 주소에 따라 메모리에서 명령어를 가져와 실행한다. 일반적으로 명령어는 **순차적으로 실행**된다. PC레지스터 값은 **순차적으로 증가**한다. 그러나 예외가 있음 ! if문으로 대표되는 분기 점프, 함수 호출 반환 등 제어 이전과 관련된 일부 기계 명령어는 **새로운 명령어 주소를 PC레지스터에 저장**한다.

CPU의 PC레지스터를 제어하는 것은 CPU의 실행 흐름을 장악하는 것.

## 4.9.4 상태 레지스터

CPU 내부에는 이 외에도 **상태 레지스터** 라는 것이 있다. x86구조에서는 이를 FLAGS라고 하며, ARM 구조에서는 응용프로그램 상태 레지스터라고 한다. 이 레지스터는 상태를 저장한다.

예를들어 올림수, 넘침 등의 정보가 상태 레지스터에 저장된다.

이외에 CPU는 기계 명령어를 실행할때 커널/사용자 상태 두개의 상태를 가진다.

대부분 우리가 작성한 코드는 사용자 상태에서 실행, 그런데 어떤 상태에서 동작하는지 어떻게 알 수 있을까 ? 이 답도 **`상태 레지스터`**에 있다. 이 레지스터에는 CPU가 현재 어떤 상태에서 동작중인지 표시하는 특정 비트가 있다. 값을 바꾸어 상태도 변경 가능.

## 4.9.5 상황 정보

레지스터를 통해 프로그램이 실행된 직후부터 현시점까지 세세한 단면을 알 수 있으며, 현 시점에 레지스터에 저장된 모든 정보를 일반적으로 `상황정보`라고 한다.

이 상황정보를 저장하고 복원해야 하는 이유?⇒ CPU는 엄격한 오름차순으로 기계 명령어를 실행하지 않기 때문.

1. CPU는 함수 A에서 B로 점프 가능
2. 사용자상태→커널상태 전환 가능
3. A기계명령어 실행상태에서 B기계명령어 실행상태 전환 가능
4. 인터럽트 처리하기 위해 실행하던 프로그램 중지 가능

이후 복구 대비해서 중단되기 전 상태를 저장해야한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/90a09c4e-65c9-42e2-a5cd-9a57c2d2eb3a/Untitled.png)

상황 정보를 저장하는 방법은 무엇일까 ?

어디에 저장될까 ?

어떻게 복원할까 ?

그리고 네가지 상황은 어떻게 구현될까 ?

## 4.9.6 중첩과 스택

회의실 상황….

함수 결과값에 따라 달라지는 상황..

자료를 타고타고 찾아가는 상황..

이와 같은 작업들은 모두 중첩된 구조를 갖고있다. 의존관계.

함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리는 모두 중첩 구조이기 때문에 스택을 이용하여 처리할 수 있다.

## 4.9.7 함수 호출과 실행 시간 스택

함수 호출할때 어려운 점은 CPU가 호출된 함수의 첫 번째 기계 명령어로 점프한 이후 **함수 실행이 완료되면, 다시 원래 위치로 점프**해야 한다는 것. 이는 함수 상태의 보존과 복원을 포함. 보존해야 하는 상태 정보에는 반환 주소 뿐만 아니라 사용한 레지스터 정보 등도 포함.

모든 함수 실행 시 모두 독점적인 자신만의 저장 공간을 가지고 있다. 이 저장 공간에 함수 실행 시 상태 정보 저장 가능. 이것이 스택 프레임.

함수A가 함수B를 호출할 때 실행 시 정보는 함수 A의 스택 프레임에 저장..

함수B의 실행이 완료되면 스택 프레임 정보를 기반으로 함수 A의 실행이 재개..

## 4.9.8

디스크 파일을 읽고 쓰거나 새로운 스레드를 생성할때, 운영체제가 이 일을 한다 !

운영체제가 시스템 호출을 완료하는 데 필요한 실행 시간 스택은 어디에 있을까 ? ⇒ 바로 **커널 상태 스택**에 있다.

본래 모든 사용자 상태 스레드는 커널 상태에 대응하는 커널 상태 스택을 가지고있다.

**<시스템 호출 과정>**

처음에 프로그램이 **사용자 상태에서 실행**

시스템 호출에 대응하는 기계 명령어가 있고, 이때 CPU는 해당 명령어를 실행함

호출 명령어가 실행되면 CPU의 상태 전환이 일어나며 ,

CPU는 **사용자 상태→ 커널상태 전환**

해당 **사용자 상태 스레드에 대응하는 커널 상태 스레드를** 찾음

(\*이때 실행 상황 정보는 커널 상태 스택에 저장됨)

이어서 CPU는 커널에서 관련 코드를 실행 (이후 커널 상태 스택은 사용자 상태 스택과 마찬가지로 함수의 호출과 반환에 따라 그 크기가 증가하고 감소)

시스템 호출이 완료되면 상황정보에 따라 CPU상태 복원

**커널상태→ 사용자 상태 전환**

계~속 실행

## 4.9.9 인터럽트와 인터럽트 함수 스택

컴퓨터가 프로그램 실행 도중 키보드 키, 마우스, 입력, 네트워크 작업등을 처리할 수 있는건 인터럽트 작동 방식을 이용해 처리하기 때문**. 인터럽트는 본질적으로 현재 CPU의 실행 흐름을 끊고 특정 인터럽트 처리 함수**로 점프, 함수 실행이 완료되면 원래 위치로 다시 점프.

인터럽트 처리 함수 역시 함수이다. 그렇기 때문에 실행 시간 스택이 있어야한다.

구현방식

- 자체적인 실행 시간 스택이 없는 경우 처리 함수는 커널 상태 스택을 이용하여 인터럽트 처리를 실행
- 처리함수에 처리함수 스택, 즉 **ISR 스택**이라는 자체적인 실행 시간 스택이 있는 경우가 있다. 인터럽트를 처리하는 것은 CPU라서 모든 CPU가 자신만의 인터럽트 처리 함수 스택을 가진다.

시스템 콜은 사용자 상태 프로그램이 직접 실행하는데 반해 인터럽트 처리는 외부 장치로 실행됨

다시 말해 CPU가 사용자 상태에서 모든 기계 명령어를 실행할 때마다 인터럽트가 발생할 수 있다.

## 4.9.10 스레드 전환과 커널 상태 스택

시스탬 내부 타이머가 인터럽트 신호를 발생시키면 CPU는 인터럽트 신호를 수신후 현재 스레드를 일시 중지

사용자 상태→ 커널 상태로 전환

커널 안의 타이머 인터럽트 처리 프로그램을 실행시킴

<스레드 전환 작업>

1. 주소 공간 전환: 스레드 A와 스레드B는 서로 다른 프로세스에 속해 있을 수 있으며, 서로 다른 프로세스의 주소 공간은 다르다.
2. CPU를 스레드 A에서 스레드 B로 전환하는 것 : 이 작업의 주된 내용은 스레드 A의 CPU 상황 정보를 저장하고 스레드 B의 CPU상황 정보를 복원하는 것을 포함

모든 리눅스 스레드에는 각 대응하는 프로세스 서술자인 task_struck 구조체가 있으며, 그 안의 구조체가 CPU의 정보를 저장하는 역할을 한다.

# 4.10 요약

CPU와 메모리 없이 프로그램 실행이 불가능하다.
