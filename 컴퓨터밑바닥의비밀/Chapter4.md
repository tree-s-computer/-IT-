# 트랜지스터

이 기능은 간단하다. 단자 한쪽에 전류가 흐르면 나머지 단자 두개에 전류가 흐르게 할 수도 있고 흐르지 못하게 할 수도 있다.

## 4.1.2 논리곱, 논리합, 논리부정

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/8c7d45ef-e401-4520-a927-284e3b53ed25/Untitled.png)

세가지 회로

- **[논리곱 게이트]** 스위치 두개가 동시에 켜질때만 전류가 흐르고 등이 켜짐
- **[논리합 게이트]** 두 스위치 중 둘 중 하나라도 켜져있으면 전류가 흐를 수 있고 등이 켜짐
- **[논리부정 게이트] 스**위치를 닫으면 전류가 흘러 등이 켜짐, 열면 전류가 흐르지 않고 등이 꺼짐

## 4.1.3 도는 하나를 낳고, 하나는 둘을 낳고,. …

(어떤것이 존재하면 모든 것은 존재할수 있다.(?))

이 세개로 모든 함수를 표현할수 있다. 이것을 논리적 완전성이라고 한다.

## 4.1.4 연산 능력은 어디에서 나올까?

[1 **자리 올림수** `자리올림數`](https://wordrow.kr/%EC%9E%90%EC%84%B8%ED%95%9C-%EC%9D%98%EB%AF%B8/%EC%9E%90%EB%A6%AC%20%EC%98%AC%EB%A6%BC%EC%88%98/1/) : 컴퓨터의 가산 논리 회로에서 이진수 값을 덧셈한 결과, 어떤 자리의 숫자의 합이 그 자리에서 나타낼 수 있는 가장 큰 수를 넘어 다음 상위 자리로 보내지는 수.

**자리올림수:** 두 입력값 모두 1일때만 1임

**배타적 논리합 :** 두 입력값이 서로 다르면 결과가 1, 서로 같으면 결과가 0

**ALU:** CPU 에 전문적으로 계산을 담당하는 모듈, 산술 논리 장치

## 4.1.5 신기한 기억 능력

설계한 조합 회로는 연산 능력은 있지만 저장할 방법이 없어 입력을 기반으로 출력을 내보낼뿐이다.

![부정 논리곱 게이트 두개를 조합한것](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/8359d5af-034c-4e08-8f8a-e22eddeb0810/Untitled.png)

부정 논리곱 게이트 두개를 조합한것

.. 부정 논리곱 게이트 또한한 **논리곱 게이트, 논리부정 게이트**를 조합한 것

**S단자와 R단자에 1이 입력되는 한** 이 회로는 다음과 같이 두가지 상태를 가진다.

단자 a가 1이면 B=0, A=1, b=0

단자 a가 0이면 B=1, A=0, b=1

**S단자를 0으로 설정하면** (R단자는 여전히 1) 회로의 출력값인 단자 a는 항상 1이 된다.

반면 **R을 0으로 설정하면** (S단자는 여전히1) 회로의 출력값인 단자 a는 항상 0이 된다.

## 4.1.6 레지스터와 메모리의 탄생

더 많은 정보를 저장하고 주소를 지정하기 위해 더 복잡한 회로를 계속해서 구축해야한다.

## 4.1.7 하드우어 아니면 소프트웨어 ? 범용장치

세상에 다양한 레시피가 있듯이 모든 연산 논리를 반드시 회로같은 하드웨어로 구현할 필요는 없다. 하드웨어는 변하지 않지만 소프트웨어는 변할수 있기에 변하지 않는 하드웨어에 서로 다른 소프트웨어를 제공하면 하드웨어가 완전히 새로운 기능을 구현할수 있다.

## 4.1.8 , 4.1.9 명령어 집합

명렁어는 16비트로 구성 , 처음 4비트는 CPU에 수행할 작업을 알려줌

R6과 R2를 더한후 레지스터 R6에 기록

시스템 계층 관점에서 보면 명령어 집합은 소프트웨어와 하드웨어가 만나는 곳이다. 소프트웨어와 하드웨어가 만나는 장소이자 서로 통신하는 인터페이스

기계 명령어 하나가 할 수 있는 일은 사실 매우 간단하다. CPU 는 기계 명령어만 이해할 수 있으므로 고급 프로그래밍 언어를 기계 명령어로 변환하는 도구가 필요하고, 바로 이 도구가 컴파일러다.

회로에는 많은 부분으로 구성되어있다. 일부는 **데이터를 계산하는데 사용되고 일부는 정보를 저장**하는데 사용된다. 각 부분 회로와 함께 작업할 수 있도록 조정하거나 동기화하려면 어떻게 해야할까 ?

CPU 에서 지휘자 역할을 맡고 있는 것이 **클럭신호**이다. (**CPU의 속도를 나타내는 단위**)

## 4.1.11 CPU 탄생

산술 논리 장치, 레지스터, 클럭 이를 한데 묶은 것을 일컬어 중앙처리장치 즉 CPU또는 프로세서라고 한다.

## 4.2.1

프로세스도 운영체제의 대기열로 관리된다. 운영체제도 프로세스에 우선 순위를 할당하고, 우선순위에 따라 스케줄러가 스케줄링을 할수 있도록 대기열에 프로세스를 넣는다. 프로세스 스케줄링은 운영 체제가 구현해야 하는 핵심 기능 중 하나이다.

## 4.2.4

스케줄링 가능한 프로세스가 없을 때 스케줄러는 유휴 프로세스를 꺼내서 실행함

CPU 설계자는 일찍이 시스템에 유휴 상태가 존재할 가능성을 고려했기 때문이 하나의 기계 명령어를 설계했다. 이 기계 명령어가 바로 정지를 의미하는 halt 명령어다. halt는 특권 명령어라 CPU 로만 실행될 수 있다.

마지막으로 프로세스 일시중지와 halt 명령어를 혼동하지 않도록 유의 바란다.

sleep 같은 함수를 호출하면 함수를 호출한 프로세스만 일시중지된다.

이때 다른 프로세스가 여전히 실행 상태라면 CPU는 유휴 상태로 진입할 수 없다.

CPU 가 halt 명령어를 실행한다는 것은 **시스템 내 더이상 실행할 준비가 완료된 프로세스가 없다는 것.**

스케줄링 가능한 프로세스가 더 이상 존재하지 않으면 스케줄러가 유휴 프로세스를 실행하는데, 이것으로 순환 구조에서 계속 halt 명령어가 실행된다. halt 명령어로 CPU 는 저전력 상태로 진입하기 시작한다.

## 4.2.6 무한 순환 탈출

while.. 어떻게 빠져나오나 ?

컴퓨터 운영 체제는 일정 시간마다 타이머 인터럽트를 생성하고, CPU는 인터럽트 신호를 감지하고,운영 체제 내부의 인터럽트 처리 프로그램을 실행한다. 상응하는 인터럽트 처리 함수에서는 프로세스가 실행될 준비가 되었는지 판단한다.

**준비가 되었다면?** 중단되었던 프로세스를 계속 실행한다.

**준비가 되어있지 않았다면?** 프로세스를 일시 중지시키고, 스케줄러는 준비 완료 상태인 다른 프로세스를 스케줄링한다.

프로그램에 무한 순환이 있더라도 운영체제는 인터럽트를 통해 제어할수 있다.

## 4.3

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/ecd40dde-bdf8-47f0-8e6c-1d3326792639/Untitled.png)

### 부호있는 정수

[부호-크기 표현] 최상이 비트를 1로만 바꾸기만 함. 아주 간단하고 인간의 사고방식에 가까움.

[1의 보수] 모든 비트를 반전시킴

## 4.4 CPU 가 if문을 만났을때

## 4.5 CPU 코어 수와 스레드 수 사이의 관계

단일 코어/ 멀티코어가 스레드 갯수와 관련이 있다고 생각하나?⇒ 아님

CPU는 하드웨어. 스레드는 소프드웨어개념.→ 더 정확하게는 실행 흐름이자 작업.

따라서 단일 코어 시스템에서도 얼마든지 많은 스레드를 생성할 수 있다.

물론 메모리가 충분하고 운영체제에 제한이 없어야 한다.

CPU 는 근본적으로 자신이 실행하는 명령어가 어떤 스레드에 속하는지 이해하지 못한다. 이를 이해해야 하는 것은 운영체제 이다. CPU 가 해야 하는 일은 PC 레지스터 주소에 따라 메모리에서 기계 명령어를 꺼내 실행하는 것 뿐이다.

작업 하나를 여러 개로 분할한 후 각각의 하위 작업을 별도의 스레드에 배치하면 운영체제에서 이를 스케줄링하고 실행할 수 있으므로 동시에 여러 작업을 실행할 수 있다.

사용자 요청도 하나의 작업,

디스크를 읽고 쓰는 것도 하나의 작업에 해당한다.

예를들어 사용자 인터페이스 요소 뒤에서 대량의 계산을 수행해야 한다고 한다. 계산 작업을 별도의 스레드에 넣어 계산을 수행하는 동안 사용자 인터페이스가 멈추는 것을 방지할 수 있다. 이외에도 처리해야 하는 작업이 블로킹 입출력과 관련이 되었을때 블로킹 호출이 실행되면 운영체제가 전체 스레드를 일시 중지하므로 호출 되에 있는 코드도 실행되지 않는다.

# 4.6 CPU 진화론(상): 복잡 명령어 집합의 탄생

## 4.6.1 프로그래머의 눈에 보이는 CPU

간단한 프로그램이든 복잡한 프로그램이든 결국 컴파일러로 하나하나 간단한 기계 명령어로 변환한다. 하나는 많은 명령어를 포함하고, 하나는 적은 수의 명령어를 포함하고 있을 뿐이다. 이런 명령어는 실행 파일에 저장되며 프로그램이 실행되면 메모리에 적재된다. **CPU는 단순하게 메모리에서 명령어를 읽어 실행하기만 하면 된다.**

## 4.6.2 CPU의 능력 범위: 명령어 집합

CPU의 능력 범위

- 덧셈 가능
- 메모리에서 레지스터로 데이터 이동시킬수있음
- 점프 가능
- 크기 비교 가능

우리가 명령어 집합에서 명령어를 하나 찾아 CPU로 보내면 CPU는 해당 명령어가 지시하는 작업을 실행한다.

예를들면 ADD명령어가 주어지면 CPU는 덧셈 계산을 수행한다. 명령어 집합은 당연히 프로그래머가 프로그래밍에 사용한다. 최초의 프로그램은 CPU에 대응하느 어셈블리어로 작성되었다.

### 집합 컴퓨터

첫 번째 명령 집합 유형이자 처음으로 탄생했던 명령어 집합이다. 오늘날 데스크톱 PC와 서버에 공통으로 사용되는 x86 구조는 복잡 명령어 집합에 기초를 두고있다. 이런 x86프로세서를 생산하는 제조업체는 우리에게 친숙한 인텔과 AMD다.

인텔:  [미국](https://namu.wiki/w/%EB%AF%B8%EA%B5%AD)의 [종합반도체사](https://namu.wiki/w/%EC%A2%85%ED%95%A9%EB%B0%98%EB%8F%84%EC%B2%B4%EC%82%AC)

AMD:[미국](https://namu.wiki/w/%EB%AF%B8%EA%B5%AD)의 [반도체](https://namu.wiki/w/%EB%B0%98%EB%8F%84%EC%B2%B4) 기업으로 [실리콘밸리](https://namu.wiki/w/%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC)의 1세대 주요 기업 중 하나였다. 각각 [x86](https://namu.wiki/w/x86) 기반의 소비자용 [CPU](https://namu.wiki/w/CPU) 분야에서는 [인텔](https://namu.wiki/w/%EC%9D%B8%ED%85%94), 외장 [GPU](https://namu.wiki/w/GPU) 분야에서는 [NVIDIA](https://namu.wiki/w/NVIDIA)와 경쟁하고 있는 유일한 사업자이다.

X86:[인텔](https://namu.wiki/w/%EC%9D%B8%ED%85%94)이 **1978년**에 출시한 [**인텔 8086**](https://namu.wiki/w/%EC%9D%B8%ED%85%94%208086)에 적용된 아키텍처이자, 그 호환 프로세서와 후속작을 이르는 말이다. 1978년에 출시되어 40년이 지난 굉장히 오래된 아키텍처이지만, 이후에 출시된 프로세서들은 8086의 명령어 세트를 기반으로 하여 확장된 것이다. 이러한 이유로 **32비트 CPU는 x32라고 표기하지 않고 x86이라고 표기한다.**

## 4.6.3

1970년까지는 컴파일러가 아직 성숙하지 못해서 컴파일러를 신뢰하지 않는 사람도 많았다. 그 시기의 대부분의 프로그램은 직접 어셈블리어로 작성되었기 때문에 일반적으로 명령어 집합이 더욱 더 풍부해야하며 **명령어 자체 기능도 더 강력해야 한다고 여겼다.**

현재 컴파일러가 발전해서 어셈블리어의 존재를 거의 인지하지 못하지만 안타까워할 일은 아니다. 고급 언어 프로그래밍의 효율성은 이미 어셈블리어가 범접할 수 없는 곳에 있다.

이 시기 대부분의 프로그램을 어셈블리어로 작성되었고, **자주 사용하는 작업마다 대응하는 특정 명령어가 있는 것이 가장 합리적**이었으며, 결국 모든 사람이 어셈블리어로 직접 프로그램을 작성했기 때문에 이 방식은 매우 편리하다 여겨졌다.

### 의미상 간격

당시에는 함수 호출, 순한 제어, 복잡한 주소 지정 패턴, 데이터 구조, 배열 접근 등 고급 언어의 개념과 이에 직접 대응하는 기계 명령어가 있어야 한다고 생각했다. 이렇게 **기계 명령어와 고급 언어 개념간 차이를 줄여야만** 더 적은 코드로 더 많은 작업을 할 수 있었기 때문.

어셈블리어로 코드를 작성할 때 편리하다는 점 외에도 고려해야할 또 다른 사항은 저장 공간의 효율적인 사용에 대한 것이다.

## 4.6.4 코드도 저장 공간을 차지한다

오늘날의 컴퓨너틑 기본적으로 **폰 노이만 구조**를 따른다.

“저장 개념에서 프로그램과 프로그램이 사용하는 데이터에 어떠한 차이도 없어야 한며, 모든 컴퓨터의 저장 장치 안에 저장될 수 있어야 한다.”

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/6784d913-3574-4ad2-9c48-9ad290b967e3/Untitled.png)

(폰노이만 구조에서는) 실행 파일은 **기계 명령어와 데이터를 모두 포함**하고 있다는 것을 알 수 있다.

또 프로그래머가 작성한 코드는 디스크 저장 공간을 차지하며 실행 시에는 메모리에 적재되므로 메모리 저장 공간을 차지한다.

작은 메모리에 더 많은 프로그램을 적재하려면 기계명령어를 매우 세밀하게 설계해 프로그램이 차지하는 저장공간을 줄여야한다.

1. 하나의 기계명령어로 많은 작업을 완료할 수 있으므로
2. 고정되어있지 않은 명령어, 가변적
3. 밀도를 높여 인코딩

## 4.6.5 필연적인 복잡 명령어 집합의 탄생

명령어를 사용한 편리한 프로그램을 작성하고 코드의 저장 공간을 절약해야 했기에 복잡 명령어 집합을 설계해야 하는 필요성이 대두되었다. 복잡 명령어 집합을 탄생시켰다.

새로운 문제 :

이 시기 CPU 명령어 집합은 모두 직접 연결 방식이었다. 즉 명령어 인출, 명령어 해독, 실행 등 각 단계가 특정 조합 회로로 직접 제어된다. 명령어 실행하는데는 매우 효율적이지만 유연성은 매우 떨어져 명령어 집합의 변경에 대응하기 어렵다. 새로운 명령어를 추가하면 CPU설계와 디버깅 복잡도가 높아지며 특히 복잡 집합의 명령어는 길이가 고정되어있지 않아 복잡한 연산 등이 포함되면 문제가 더 악화될 수 있다.

문제 본질 : 하드웨어를 변경하는 것은 매우 번거롭고, 소프트웨어는 이와 다르게 쉽게 변경할 수 있음.

![여기서 사용되는 더 간단한 명령어가 바로 마이크로 코드이다. ](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/d0a669d4-f686-4f91-a064-502b98d5ec22/Untitled.png)

여기서 사용되는 더 간단한 명령어가 바로 마이크로 코드이다.

명령어에 포함된 연산을 더 간단한 명령어로 구성된 작은 프로그램으로 정의하고 이를 CPU에 저장하면, 모든 기계 명령어에 대응하여 전용 하드웨어 회로를 설계할 필요 없다. 즉 소프트웨어가 하드웨어를 대체하게 되는 것이다.

더 많은 명령어를 추가할 때, 주요 작업은 마이크로코드 수정에 집중되며 하드웨어 수정은 거의 필요 하지 않다.

## 4.6.6 마이크로코드 설계의 문제점

복잡 명령어 집합이 등장하면서 프로그래머는 어셈블리어로 프로그램을 더 쉽게 작성할 수 있게 되었고 저장공간의 효율도 높아졌다.복잡명령어 집합으로 발생하는 프로세서 설계의 복잡한 문제는 마이크로 코드로 단순화 할 수 있었다.

또다른 문제 : 버그..

마이크로 코드 버그 수정은 어렵고 마이크로 코드 설계는 트랜지스터를 매우 많이 소모한다.

트랜지스터:

# 4.7 CPU진화론(중) 축소 명령어 집합의 탄생

복잡 명령어 출현은 초기단계의 컴파일러, 저장장치의 용량 제한같은 객관적인 조건의 제한이었다

기술이 발전하고 메모리 용량이 늘어나고 가격이 급속도로 떨어졌다.

컴파일러 기술이 점점 발전하고 프로그래머도 점점 고급 언어로 프로그램을 작성하기 시작했다. 컴파일러에 의존하여 어셈블리어 명령어를 자동으로 생성했다.

복잡한 명령어를 간단한 명령어 여러개로 대체하면 안되는 이유가 뭘까 ?

## 4.7.2 축소 명령어 집합의 철학

### 1. 명령어 자체의 복합성

명령어 집합을 줄인다는 것은 명령어 집합의 명령어 갯수가 줄아든다는 단순한 의미가 아니다.

하나의 명령어당 들여야 하는 연산이 더 간단하다는 것을 의미한다.

먹는다: 먹을준비하고씻고어쩌구저쩌구

한입베어먹는거그자체

### 2. 컴파일러

컴파일러가 CPU에 대한 강력한 제어권을 갖는다.

복잡 명령어 집합에서 CPU는 마이크로코드같은 기계 명령어의 실행 세부사항을 컴파일러에 숨기므로 컴파일러는 아무것도 알 수 없다. 하지만 축소 명령어 집합은 CPU에 많은 세부사항을 컴파일러에 제공한다.

### 3. LOAD/STORE 구조

**복잡 명령어:** 데이터를 가져오고, 작업을 수행하고 해당 데이터를 메모리에 다시 쓰는 작업을 모두 할 수 있다. 단지 하나의 기계 명령어로 수행된다는것.

**축소 명령어 집합**에서 이것은 절대 불가능함 금기. **레지스터내 데이터만 처리할 수 있으며** 메모리 내 데이터는 직접 처리할 수 없다. 하지만 결국 데이터는 여전히 메모리 내에 저장되어있다.

LOAD/STORE 라는 전용 기계 명령어가 메모리의 읽고 쓰기를 책임진다.

다른 명령어들은 CPU내부의 레지스터만 처리할 수 있으며 메모리를 읽거나 쓸 수 없다.

## 4.7.3 복잡 명령어 집합과 축소 명령어 집합의 차이

![왼쪽은 CPU, CPU내부에 있는 것은 레지스터와 연산 장치인 ALU. 
오른쪽은 기계 명령어와 데이터를 저장하는 메모리.](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/d8885956-e8a7-47a6-a4b3-4198575a74e9/Untitled.png)

왼쪽은 CPU, CPU내부에 있는 것은 레지스터와 연산 장치인 ALU.
오른쪽은 기계 명령어와 데이터를 저장하는 메모리.

두 숫자가 각각 메모리 주소 A,B에 저장된다.

### 1. 복잡 명령어 집합의 경우

사상: 가능하면 적은 수의 기계 명령어고 **가능한 많은 작업**을 수행하라!

MULT A B

MULT는 복잡한 명령어

이 명령어에 엄청 많은 작업이 포함되어있음

고급 언어와 매우 유사함

### 2. 축소 명령어 집합의 경우

사상: 반대로 **간단한 명령어 여러개**를 사용하여 작업을 완료하라!

ㅇㅋ..잘게 쪼게느낌…?

## 4.7.4 명령어 파이프라인

축소 명령어 집합에서 생성된 명령어들 …

각 명령어가 매우 간단하여 실행시간이 모두 거의 동일하다. 이 경우 기계 명령어의 실행 효율을 높이는 방법을 사용할 수 있는데, 이 기술이 파이프라인 기술이다.

파이프라인 기술은 비록 기계 명령어 하나가 실행되는 시간을 단축해주지 않지만 처리량을 늘릴 수 있다.

복잡 명령어 집합에서는 명령어 사이에 비교적 차이가 크기에 실행 시간이 고르지 않다. 따라서 기계 명령어를 효율적으로 실행하기 위해 파이프라인 방식을 제대로 활용할 방법이 없다.

1세대 축소 명령어 집합 프로세서는 전체가 파이프라인 기반으로 설계되어 일반적으로 5단계 파이프라인 기준으로 명령어 하나가 1~2클럭 주기로 실행된다. 반면에 동시애 복잡 명령어 집합 프로세서는 5~10클럭 주기가 필요하다.

높은 클럭 주파수를 가지게 되어 축소 명령어 집합 구조의 CPU는 동일한 작업을 할때 복잡 명령어 구조보다 우수하다.

## 4.7.5 천하에 명성을 떨치다

1980년 후반대에는 축소 명령어 집합으로 설계된 CPU가 성능 면에서 기존 모든 전통적인 설계를 가볍게 진압했다.

# 4.8 CPU 진화론(하): 절체절명의 위기에서의 반격
