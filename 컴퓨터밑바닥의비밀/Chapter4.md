# 트랜지스터

이 기능은 간단하다. 단자 한쪽에 전류가 흐르면 나머지 단자 두개에 전류가 흐르게 할 수도 있고 흐르지 못하게 할 수도 있다.

## 4.1.2 논리곱, 논리합, 논리부정

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/8c7d45ef-e401-4520-a927-284e3b53ed25/Untitled.png)

세가지 회로

- **[논리곱 게이트]** 스위치 두개가 동시에 켜질때만 전류가 흐르고 등이 켜짐
- **[논리합 게이트]** 두 스위치 중 둘 중 하나라도 켜져있으면 전류가 흐를 수 있고 등이 켜짐
- **[논리부정 게이트] 스**위치를 닫으면 전류가 흘러 등이 켜짐, 열면 전류가 흐르지 않고 등이 꺼짐

## 4.1.3 도는 하나를 낳고, 하나는 둘을 낳고,. …

(어떤것이 존재하면 모든 것은 존재할수 있다.(?))

이 세개로 모든 함수를 표현할수 있다. 이것을 논리적 완전성이라고 한다.

## 4.1.4 연산 능력은 어디에서 나올까?

[1 **자리 올림수** `자리올림數`](https://wordrow.kr/%EC%9E%90%EC%84%B8%ED%95%9C-%EC%9D%98%EB%AF%B8/%EC%9E%90%EB%A6%AC%20%EC%98%AC%EB%A6%BC%EC%88%98/1/) : 컴퓨터의 가산 논리 회로에서 이진수 값을 덧셈한 결과, 어떤 자리의 숫자의 합이 그 자리에서 나타낼 수 있는 가장 큰 수를 넘어 다음 상위 자리로 보내지는 수.

**자리올림수:** 두 입력값 모두 1일때만 1임

**배타적 논리합 :** 두 입력값이 서로 다르면 결과가 1, 서로 같으면 결과가 0

**ALU:** CPU 에 전문적으로 계산을 담당하는 모듈, 산술 논리 장치

## 4.1.5 신기한 기억 능력

설계한 조합 회로는 연산 능력은 있지만 저장할 방법이 없어 입력을 기반으로 출력을 내보낼뿐이다.

![부정 논리곱 게이트 두개를 조합한것](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/8359d5af-034c-4e08-8f8a-e22eddeb0810/Untitled.png)

부정 논리곱 게이트 두개를 조합한것

.. 부정 논리곱 게이트 또한한 **논리곱 게이트, 논리부정 게이트**를 조합한 것

**S단자와 R단자에 1이 입력되는 한** 이 회로는 다음과 같이 두가지 상태를 가진다.

단자 a가 1이면 B=0, A=1, b=0

단자 a가 0이면 B=1, A=0, b=1

**S단자를 0으로 설정하면** (R단자는 여전히 1) 회로의 출력값인 단자 a는 항상 1이 된다.

반면 **R을 0으로 설정하면** (S단자는 여전히1) 회로의 출력값인 단자 a는 항상 0이 된다.

## 4.1.6 레지스터와 메모리의 탄생

더 많은 정보를 저장하고 주소를 지정하기 위해 더 복잡한 회로를 계속해서 구축해야한다.

## 4.1.7 하드우어 아니면 소프트웨어 ? 범용장치

세상에 다양한 레시피가 있듯이 모든 연산 논리를 반드시 회로같은 하드웨어로 구현할 필요는 없다. 하드웨어는 변하지 않지만 소프트웨어는 변할수 있기에 변하지 않는 하드웨어에 서로 다른 소프트웨어를 제공하면 하드웨어가 완전히 새로운 기능을 구현할수 있다.

## 4.1.8 , 4.1.9 명령어 집합

명렁어는 16비트로 구성 , 처음 4비트는 CPU에 수행할 작업을 알려줌

R6과 R2를 더한후 레지스터 R6에 기록

시스템 계층 관점에서 보면 명령어 집합은 소프트웨어와 하드웨어가 만나는 곳이다. 소프트웨어와 하드웨어가 만나는 장소이자 서로 통신하는 인터페이스

기계 명령어 하나가 할 수 있는 일은 사실 매우 간단하다. CPU 는 기계 명령어만 이해할 수 있으므로 고급 프로그래밍 언어를 기계 명령어로 변환하는 도구가 필요하고, 바로 이 도구가 컴파일러다.

회로에는 많은 부분으로 구성되어있다. 일부는 **데이터를 계산하는데 사용되고 일부는 정보를 저장**하는데 사용된다. 각 부분 회로와 함께 작업할 수 있도록 조정하거나 동기화하려면 어떻게 해야할까 ?

CPU 에서 지휘자 역할을 맡고 있는 것이 **클럭신호**이다. (**CPU의 속도를 나타내는 단위**)

## 4.1.11 CPU 탄생

산술 논리 장치, 레지스터, 클럭 이를 한데 묶은 것을 일컬어 중앙처리장치 즉 CPU또는 프로세서라고 한다.

## 4.2.1

프로세스도 운영체제의 대기열로 관리된다. 운영체제도 프로세스에 우선 순위를 할당하고, 우선순위에 따라 스케줄러가 스케줄링을 할수 있도록 대기열에 프로세스를 넣는다. 프로세스 스케줄링은 운영 체제가 구현해야 하는 핵심 기능 중 하나이다.

## 4.2.4

스케줄링 가능한 프로세스가 없을 때 스케줄러는 유휴 프로세스를 꺼내서 실행함

CPU 설계자는 일찍이 시스템에 유휴 상태가 존재할 가능성을 고려했기 때문이 하나의 기계 명령어를 설계했다. 이 기계 명령어가 바로 정지를 의미하는 halt 명령어다. halt는 특권 명령어라 CPU 로만 실행될 수 있다.

마지막으로 프로세스 일시중지와 halt 명령어를 혼동하지 않도록 유의 바란다.

sleep 같은 함수를 호출하면 함수를 호출한 프로세스만 일시중지된다.

이때 다른 프로세스가 여전히 실행 상태라면 CPU는 유휴 상태로 진입할 수 없다.

CPU 가 halt 명령어를 실행한다는 것은 **시스템 내 더이상 실행할 준비가 완료된 프로세스가 없다는 것.**

스케줄링 가능한 프로세스가 더 이상 존재하지 않으면 스케줄러가 유휴 프로세스를 실행하는데, 이것으로 순환 구조에서 계속 halt 명령어가 실행된다. halt 명령어로 CPU 는 저전력 상태로 진입하기 시작한다.

## 4.2.6 무한 순환 탈출

while.. 어떻게 빠져나오나 ?

컴퓨터 운영 체제는 일정 시간마다 타이머 인터럽트를 생성하고, CPU는 인터럽트 신호를 감지하고,운영 체제 내부의 인터럽트 처리 프로그램을 실행한다. 상응하는 인터럽트 처리 함수에서는 프로세스가 실행될 준비가 되었는지 판단한다.

**준비가 되었다면?** 중단되었던 프로세스를 계속 실행한다.

**준비가 되어있지 않았다면?** 프로세스를 일시 중지시키고, 스케줄러는 준비 완료 상태인 다른 프로세스를 스케줄링한다.

프로그램에 무한 순환이 있더라도 운영체제는 인터럽트를 통해 제어할수 있다.

## 4.3

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/ecd40dde-bdf8-47f0-8e6c-1d3326792639/Untitled.png)

### 부호있는 정수

[부호-크기 표현] 최상이 비트를 1로만 바꾸기만 함. 아주 간단하고 인간의 사고방식에 가까움.

[1의 보수] 모든 비트를 반전시킴

## 4.4 CPU 가 if문을 만났을때

## 4.5 CPU 코어 수와 스레드 수 사이의 관계

단일 코어/ 멀티코어가 스레드 갯수와 관련이 있다고 생각하나?⇒ 아님

CPU는 하드웨어. 스레드는 소프드웨어개념.→ 더 정확하게는 실행 흐름이자 작업.

따라서 단일 코어 시스템에서도 얼마든지 많은 스레드를 생성할 수 있다.

물론 메모리가 충분하고 운영체제에 제한이 없어야 한다.

CPU 는 근본적으로 자신이 실행하는 명령어가 어떤 스레드에 속하는지 이해하지 못한다. 이를 이해해야 하는 것은 운영체제 이다. CPU 가 해야 하는 일은 PC 레지스터 주소에 따라 메모리에서 기계 명령어를 꺼내 실행하는 것 뿐이다.

작업 하나를 여러 개로 분할한 후 각각의 하위 작업을 별도의 스레드에 배치하면 운영체제에서 이를 스케줄링하고 실행할 수 있으므로 동시에 여러 작업을 실행할 수 있다.

사용자 요청도 하나의 작업,

디스크를 읽고 쓰는 것도 하나의 작업에 해당한다.

예를들어 사용자 인터페이스 요소 뒤에서 대량의 계산을 수행해야 한다고 한다. 계산 작업을 별도의 스레드에 넣어 계산을 수행하는 동안 사용자 인터페이스가 멈추는 것을 방지할 수 있다. 이외에도 처리해야 하는 작업이 블로킹 입출력과 관련이 되었을때 블로킹 호출이 실행되면 운영체제가 전체 스레드를 일시 중지하므로 호출 되에 있는 코드도 실행되지 않는다.
