상호작용이란 ? 컴퓨팅 장치의 입력과 출력을 의미한다.

**마지막 단계:** 저수준 계층에서 시작하여 하드웨어에서 소프트웨어 순으로 CPU, 운영체제, 프로세스와 입출력 관계를 이해하는 시간

## 6.1 CPU는 어떻게 입출력 작업을 처리할까 ?

CPU내부에 레지스터가 있는 것과 마찬가지로 장치에도 레지스터인 장치 레지스터가 있다.

**CPU의 레지스터**는 메모리에서 읽은 데이터를 임시로 저장하거나 **CPU에서 계산한 중간 결과를 저장하는데 사용된다. 장치 레지스터**는 주로 **장치에 관련된 일부 정보**를 저장한다.

1. 데이터를 저장하는 레지스터
2. 제어 정보와 **상태 정보**를 저장하는 레지스터

프로그래머의 관점에서의 장치: 저수준 계층의 레지스터를 한데 묶은 것에 불과

어떻게 장치 레지스터를 읽고 쓰는가 ?

⇒ 기계 명령어로 실행한다.

그렇다면 이런 기계 명령어는 또 어떻게 설계하는가 ?

[ 키워드: CPU의 레지스터/ 장치레지스터 ]

## 6.1.1 전문적으로 처리하기 : 입출력 기계 명령어

산술계산, 점프, 메모리같은 특정 기계 명령어등을 **입출력 명령어**라고 한다.

CPU입장에서는 메모리 역시 하나의 **‘외부 장치’**로 간주할 수 있다.

메모리를 읽고 쓰는 축소 명령어 집합의 LOAD와 STORE명령어 등 특정한 명령어가 있다. 그렇다면 메모리를 읽고 쓰는 것 처럼 간단히 장치 레지스터도 읽고 쓸 수 있지 않을까 ?

의문 : CPU가 LOAD STORE명령어 실행한다는게 무슨 의미지 ?
CPU가 실행한다는건 명령어를 내가 직접 입력하는건가?

아님 특정 행동을 내가 CPU에게 지시해야 한다는건가 ?

## 6.1.2 메모리 사상 입출력

LOAD STORE명령어가 전달하는 정보 : 메모리 주소 공간을 전달한다.

메모리 주소 공간과 실제 메모리 주소는 서로 다른 개념이라는 점에 유의.

**메모리 사상 입출력 :** 주소 공간의 일부분을 장치에 할당, 메모리를 읽고 쓰는 것처럼 장치를 제어하는 방법

**[ 저수준 계층에 두가지 입출력 구현 방법 ]**

1. 특정 입출력 기계 명령어 사용
2. 메모리의 읽기와 쓰기 명령어를 함께 사용, 주소 공간의 일부분을 장치에 할당

## 6.1.3 CPU가 키보드를 읽고 쓰는 것으 ㅣ본질

**[ 메모리 사상 입출력 방식 채용 ]**

아무리 고수준 계층이 복잡하게 구성되어있더라도 CPU가 키보드의 데이터를 읽는데는 이 명령어 하나면 충분.

CPU가 하나의 기계 명령어를 실행하는 데 걸리는 시간은 0.5ms에 불과하다.

CPU는 어떻게 장치의 작업 상태를 알수 있을까 ? ⇒ 바로 장치 상태 레지스터 역할 덕분.

## 6.1.4 폴링: 계속 검사

이전 절에서 LOAD명령어를 사용하여 CPU레지스터 값을 읽을 수 있다는 것을 알았다.

이번엔 BLZ라는 분기 점프 명령어가 있다고 가정. 이 명령어는 이전 명령어 결과가 0이면 지정된 위치로 점프.

**while 돌려서 끊임없이 검사 :** 폴링

**폴링의 문제점 :** 사용자가 키를 누르지 않으면 불필요하게 순환하며 대기

폴링은 동기식 설계 방식.

## 6.1.5 배달 음식 주문과 중단 처리

**동기:** 배달 음식 주문하고 휴대폰만 처리하며 기사가 어디쯤 왔는지 화면 새로고침

**비동기:** 배달 시켜놓고 다른거 한 다음에 알람이 울리면 받는 것

**인터럽트 처리과정:** 벨 울려서 배달 음식 받는행위 (인터럽트 = 초인종)

프로그램은 끊임없이 실행되는 것이 아닌, 언제든지 장치에 의해 실행이 중단될 수 있다.

## 6.1.6 인터럽트 구동식 입출력

CPU는 신호를 받으면 처리중인 작업을 내려놓고 데이터를 읽고, 데이터를 얻은 후에는 이전에 중단했던 작업을 계속 실행한다.

CPU가 실행하는 명령어 흐름

- 프로그램 실행
- 인터럽트 신호 감지
- 실행상태 저장
- 인터럽트 명령어 처리
- 실행상태 복원

~~반복~~

프로그램 A관점에서 보면 CPU는 마치 중단된 적이 없는 것 같다.

이것이 바로 프로그램A의 실행 상태를 저장,복원하는 이유.

**입출력을 비동기**로 처리하는 이 방법을 **구동식 입출력 방법이**라고 한다.

[ 키워드 : CPU 실행 흐름, 구동식 입출력 ]

## 6.1.7 CPU는 어떻게 인터럽트 신호를 감지할까 ?

CPU가 기계 명령어를 실행하는 과정

명령어 인출 / 명령어 해독 / 실행 / 다시쓰기

같은 전형적인 단계로 나눌 수 있다.

인터럽트 신호가 와도 우선순위에 따라 처리할지, 안할지 선택할 수도 있다.

인터럽트를 처리할 때는 **중단된 작업 상태를 보존**해야한다. 이어서 CPU는 인터럽트 처리 함수의 시작 위치로 점프하여 인터럽트 처리 함수의 명령어를 실행한 후 처리가 끝나면 다시 원래 자리로 점프하여 중단되었던 작업을 계속 실행한다.

## 6.1.8 인터럽트 처리와 함수 호출의 차이

인터럽트 처리는 일반 함수(사용자 상태)의 호출과 비교했을때 점프,반환을 포함하고 있다는 점에서 매우 유사하다. 함수 호출 전엔 반환주소, 일부 범용 레지스터값, 매개변수 등 저장하는 것이 필요한데, 인터럽트 처리 함수로 점프힐때는 절대 이 정도로 그치지 않는다.

- **함수 호출은?** 동일한 실행 흐름 내에 존재하기 때문.
- **인터럽트 처리 점프는?** 서로 다른 두 실행 흐름을 포함하므로 함수 호출에 비해 저장해야 할 정보가 많기 때문.

중단된 프로그램의 실행 상태를 어떻게 저장하고 복원해야할까?

⇒ 잘 떠오르지 않음..

## 6.1.9 중단된 프로그램의 실행 상태 저장과 복원

프로그램 A가 실행중일때 인터럽트 발생

프로그램 A중단

CPU는 인터럽트 처리프로그램 B로 점프

B실행시 인터럽트 발생시 B중단

CPU는 C로 점프

⇒ 인터럽트가 연속적으로 발생할 수도 있구나.

상태저장 순서 : ABC
복원순서 : BCA

CPU는 인터럽트 발생을 감지하면 커널 상태로 진입

![프로그램 B로 점프할 때 스택 상태](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/3cd0751d-f906-45a3-9808-1d818ea830d2/Untitled.png)

프로그램 B로 점프할 때 스택 상태

인터럽트 처리의 구현 원리 : 스택이 멋지게 사용된 하나의 예
