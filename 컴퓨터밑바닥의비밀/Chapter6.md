상호작용이란 ? 컴퓨팅 장치의 입력과 출력을 의미한다.

**마지막 단계:** 저수준 계층에서 시작하여 하드웨어에서 소프트웨어 순으로 CPU, 운영체제, 프로세스와 입출력 관계를 이해하는 시간

## 6.1 CPU는 어떻게 입출력 작업을 처리할까 ?

CPU내부에 레지스터가 있는 것과 마찬가지로 장치에도 레지스터인 장치 레지스터가 있다.

**CPU의 레지스터**는 메모리에서 읽은 데이터를 임시로 저장하거나 **CPU에서 계산한 중간 결과를 저장하는데 사용된다. 장치 레지스터**는 주로 **장치에 관련된 일부 정보**를 저장한다.

1. 데이터를 저장하는 레지스터
2. 제어 정보와 **상태 정보**를 저장하는 레지스터

프로그래머의 관점에서의 장치: 저수준 계층의 레지스터를 한데 묶은 것에 불과

어떻게 장치 레지스터를 읽고 쓰는가 ?

⇒ 기계 명령어로 실행한다.

그렇다면 이런 기계 명령어는 또 어떻게 설계하는가 ?

[ 키워드: CPU의 레지스터/ 장치레지스터 ]

## 6.1.1 전문적으로 처리하기 : 입출력 기계 명령어

산술계산, 점프, 메모리같은 특정 기계 명령어등을 **입출력 명령어**라고 한다.

CPU입장에서는 메모리 역시 하나의 **‘외부 장치’**로 간주할 수 있다.

메모리를 읽고 쓰는 축소 명령어 집합의 LOAD와 STORE명령어 등 특정한 명령어가 있다. 그렇다면 메모리를 읽고 쓰는 것 처럼 간단히 장치 레지스터도 읽고 쓸 수 있지 않을까 ?

의문 : CPU가 LOAD STORE 명령어 실행한다는게 무슨 의미지 ?
CPU가 실행한다는건 명령어를 내가 직접 입력하는건가?

아님 특정 행동을 내가 CPU에게 지시해야 한다는건가 ?

## 6.1.2 메모리 사상 입출력

LOAD STORE 명령어가 전달하는 정보 : 메모리 주소 공간을 전달한다.

메모리 주소 공간과 실제 메모리 주소는 서로 다른 개념이라는 점에 유의.

**메모리 사상 입출력 :** 주소 공간의 일부분을 장치에 할당, 메모리를 읽고 쓰는 것처럼 장치를 제어하는 방법

**[ 저수준 계층에 두가지 입출력 구현 방법 ]**

1. 특정 입출력 기계 명령어 사용
2. 메모리의 읽기와 쓰기 명령어를 함께 사용, 주소 공간의 일부분을 장치에 할당

## 6.1.3 CPU가 키보드를 읽고 쓰는 것의 본질

**[ 메모리 사상 입출력 방식 채용 ]**

아무리 고수준 계층이 복잡하게 구성되어있더라도 CPU가 키보드의 데이터를 읽는데는 이 명령어 하나면 충분.

CPU가 하나의 기계 명령어를 실행하는 데 걸리는 시간은 0.5ms에 불과하다.

CPU는 어떻게 장치의 작업 상태를 알수 있을까 ? ⇒ 바로 장치 상태 레지스터 역할 덕분.

## 6.1.4 폴링: 계속 검사

이전 절에서 LOAD명령어를 사용하여 CPU레지스터 값을 읽을 수 있다는 것을 알았다.

이번엔 BLZ라는 분기 점프 명령어가 있다고 가정. 이 명령어는 이전 명령어 결과가 0이면 지정된 위치로 점프.

**while 돌려서 끊임없이 검사 :** 폴링

**폴링의 문제점 :** 사용자가 키를 누르지 않으면 불필요하게 순환하며 대기

폴링은 동기식 설계 방식.

## 6.1.5 배달 음식 주문과 중단 처리

**동기:** 배달 음식 주문하고 휴대폰만 처리하며 기사가 어디쯤 왔는지 화면 새로고침

**비동기:** 배달 시켜놓고 다른거 한 다음에 알람이 울리면 받는 것

**인터럽트 처리과정:** 벨 울려서 배달 음식 받는행위 (인터럽트 = 초인종)

프로그램은 끊임없이 실행되는 것이 아닌, 언제든지 장치에 의해 실행이 중단될 수 있다.

## 6.1.6 인터럽트 구동식 입출력

CPU는 신호를 받으면 처리중인 작업을 내려놓고 데이터를 읽고, 데이터를 얻은 후에는 이전에 중단했던 작업을 계속 실행한다.

CPU가 실행하는 명령어 흐름

- 프로그램 실행
- 인터럽트 신호 감지
- 실행상태 저장
- 인터럽트 명령어 처리
- 실행상태 복원

~~반복~~

프로그램 A관점에서 보면 CPU는 마치 중단된 적이 없는 것 같다.

이것이 바로 프로그램A의 실행 상태를 저장,복원하는 이유.

**입출력을 비동기**로 처리하는 이 방법을 **구동식 입출력 방법이**라고 한다.

[ 키워드 : CPU 실행 흐름, 구동식 입출력 ]

## 6.1.7 CPU는 어떻게 인터럽트 신호를 감지할까 ?

CPU가 기계 명령어를 실행하는 과정

명령어 인출 / 명령어 해독 / 실행 / 다시쓰기

같은 전형적인 단계로 나눌 수 있다.

인터럽트 신호가 와도 우선순위에 따라 처리할지, 안할지 선택할 수도 있다.

인터럽트를 처리할 때는 **중단된 작업 상태를 보존**해야한다. 이어서 CPU는 인터럽트 처리 함수의 시작 위치로 점프하여 인터럽트 처리 함수의 명령어를 실행한 후 처리가 끝나면 다시 원래 자리로 점프하여 중단되었던 작업을 계속 실행한다.

## 6.1.8 인터럽트 처리와 함수 호출의 차이

인터럽트 처리는 일반 함수(사용자 상태)의 호출과 비교했을때 점프,반환을 포함하고 있다는 점에서 매우 유사하다. 함수 호출 전엔 반환주소, 일부 범용 레지스터값, 매개변수 등 저장하는 것이 필요한데, 인터럽트 처리 함수로 점프힐때는 절대 이 정도로 그치지 않는다.

- **함수 호출은?** 동일한 실행 흐름 내에 존재하기 때문.
- **인터럽트 처리 점프는?** 서로 다른 두 실행 흐름을 포함하므로 함수 호출에 비해 저장해야 할 정보가 많기 때문.

중단된 프로그램의 실행 상태를 어떻게 저장하고 복원해야할까?

⇒ 잘 떠오르지 않음..

## 6.1.9 중단된 프로그램의 실행 상태 저장과 복원

프로그램 A가 실행중일때 인터럽트 발생

프로그램 A중단

CPU는 인터럽트 처리프로그램 B로 점프

B실행시 인터럽트 발생시 B중단

CPU는 C로 점프

⇒ 인터럽트가 연속적으로 발생할 수도 있구나.

상태저장 순서 : ABC
복원순서 : BCA

CPU는 인터럽트 발생을 감지하면 커널 상태로 진입

![프로그램 B로 점프할 때 스택 상태](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/3cd0751d-f906-45a3-9808-1d818ea830d2/Untitled.png)

프로그램 B로 점프할 때 스택 상태

인터럽트 처리의 구현 원리 : 스택이 멋지게 사용된 하나의 예

# 6.2 디스크가 입출력을 처리할 때 CPU가 하는 일은 무엇일까 ?

최신 컴퓨터 시스템의 경우 사실 디스크가 입출력을 처리할 때 CPU개입이 필요하지 않다. 디스크 입출력은 CPU속도에 비해 매우 느리기에 입출력 요청의 처리가 완료되기 전까지 스레드1은 앞으로 나아갈 수 없다.

디스크의 입출력 처리와 CPU가 실행하는 작업은 서로 의존하지 않는 독립적인 작업이므로 병행처리가 가능하다.

## 6.2.1 장치 제어기

**탐색 :** 헤드가 특정 트랙으로 이동해야 하는 과정. 디스크 입출력중 매우 시간을 많이 소모한다.

기계 장치기 때문에 CPU속도와 비교하면 극도로 느리다.

펌웨어 ?

장치 제어기와 장치 드라이버를 혼동하지 말기.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a26ec9a-4a75-431e-ae2d-b908cda9c589/71949504-ff0b-474a-a6c9-f71a70454eff/Untitled.png)

**장치 드라이버:** 운영체에 속한 코드

**장치 제어기:** 장치 드라이버에서 명령을 받아 외부 장치를 제어하는 **하드웨어.** 운영체제에 해당하는 장치 드라이버와 외부 장치를 연결하는 다리에 해당. 장치 제어기가 점점 더 복잡해지는 목적 중 하나가 바로 CPU를 해방 시키는 것.

## 6.2.2 CPU가 직접 데이터를 복사해야할까 ?

디스크에서 자체 버퍼로 데이터를 읽었다면, CPU는 직접 데이터 전송 명령어를 실행하여 장치 제어기 버퍼에 있는 데이터를 따로 메모리로 복사애햐할까? ⇒ 그렇지 않음.

CPU입장에서 데이터를 직접 복사하는 것은 계산 리소스를 극도로 낭비하는 것.

이를 해결하기 위해 설계한 것,

**직접 메모리 접근 :** CPU개입이 없는 상황에서 직접 장치와 메모리 사이에 데이터를 전송할 수 있는 작동 방식

## 6.2.3 직접 메모리 접근

직접 메모리 접근 방식의 목적은 매우 명확. CPU 개입 없이 장치와 메모리 사이에 직접 데이터를 전송.

CPU가 직접 데이터 복사할 필요 X
하지만 어떻게 복사할지 알려주는 명령어를 DMA에 전달해야함.

DMA에게 여러가지 정보를 알려주고…그래야만 DMA가 작업을 시작 가능.

**DMA가 CPU를 해방시키면서 생긴 문제** : 가상 메모리와 캐시 지원 문제

이때 장치에서 읽은 데이터를 메모리에 저장한다고 하면 DMA는 가상 주소와 물리 메모리 주소중 어느 쪽에 저장해야 할까..

**해결책 :** 운영체제가 DMA에 필요한 가상주소와 물리 메모리 주소 사이의 **사상 정보**를 제공

**또 다른 문제** : 캐시가 동일하지 않을 수 있음.

**해결책:** 상응하는 캐시의 데이터를 즉시 메모리에 갱신

**마지막 문제:** CPU는 데이터 전송이 완료되었는지 어떻게 알 수 있는지?

**해결책 :** DMA가 데이터 전송을 완료하면 인터럽트 작동 방식을 사용하여 CPU에게 알림.

## 6.2.4 전 과정 정리

## 6.2.5 프로그래머에게 시사하는 것

비동기이기에 효율적으로 처리 가능 ?

소프트웨어 관점으로 보면 디스크 입출력 요청 처리를 하나의 단독 스레드로 간주,

CPU가 기계 명령어를 실행하는 것도 또 하나의 단독 스레드로 간주할 수 있다.

더 흥미로운 것.. 프로그램이 어떻게 파일이라는 이 추상화된 계층을 읽는가.

# 6.3 파일을 읽을 때 프로그램에는 어떤 일이 발생할까 ?

## 6.3.1 메모리 관점에서 입출력

메모리 관점에서 입출력은 단순한 메모리의 복사일뿐, 그 이상 이하도 아니다.

데이터가 외부장치→ 메모리로 복사되는 것 : 입력

데이터가 메모리→ 외부장치로 복사되는 것: 출력

I/O

입출력이 사실 데이터 복사라고 할 때, 파일 내용을 읽는 것을 예로 들면 데이터는 장치에서 프로세스 주소 공간으로 어떻게 복사될까 ?

## 6.3.2 read 함수는 어떻게 파일을 읽는 것일까 ?

전제: 단일 코어 CPU 시스템에 프로세스 A와 프로세스 B 두 개가 있을 때 프로세스 A가 현재 실행중.

read

→ 저수준 계층에서 시스템 호출을 이용하여 운영 체제에 파일 읽기 요청을 보낸다. 이 요청은 커널에서 디스크가 이해할수 있는 명령어로 변환되어 디스크로 전송된다. CPU가 명령어를 실행하는 속도에 비해 디스크 입출력은 매우 느려 운영체제는 귀중한 계산 리소스를 불필요한 대기에 낭비할 수 없다.

**외부 장치가 입출력 작업을 실행하는 것은 매우 느림.**

입출력 작업이 끝나기 전까지 프로세스는 앞으로 나아갈 수 없음. ⇒ 블로킹

- 입출력 블로킹 대기열
- 준비 완료 대기열

블로킹 대기열에도 준비완료 대기열이 존재한다. 준비완료 대기열은 **대기열 안의 프로세스가 다시 실행되는 조건이 준비되었음**을 의미한다.

입출력 데이터는 먼저 운영체제 내부로 복다쇠며 이후 운영체제가 프로세스 주소 공간으로 복사한다.

실제로 운영체에 계층이 하나가 더 존재하는 것이다.

실제로 운영체제를 건너뛰는 무복사 기법을 진행할 수 있다.

# 6.4 높은 동시성 비결 : 입출력 다중화
