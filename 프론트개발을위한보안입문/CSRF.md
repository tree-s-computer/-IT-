# CSRF

공격자가 준비한 함정에 의해 웹 애플리케이션이 원래 갖고 있는 기능이 사용자의 의도와 상관없이 호출되는 공격
xss처럼 공격자가 마음대로 스크립트를 동작시키거나 웹 애플리케이션에 요청을 생성하지는 못하지만,
송금 처리나 계정 삭제, SNS에 업로드 등 웹 애플리케이션의 기능을 악용해 요청을 전송할 수 있다.

# CSRF 공격 절차

1. 사용자가 은행 사이트에 로그인
2. 로그인에 성공하면 세션 ID가 쿠키에 기록
3. 사용자가 공격자에게 송금하기 위한 악성 폼이 삽입된 피싱 사이트로 유도
4. 사용자의 쿠키와 함께 피싱 사이트에서 은행 사이트로 요청이 자동으로 전송
5. 은행 사이트는 서버의 전송된 쿠키를 정상으로 간주해 요청 처리

# 토큰을 사용하는 CSRF 대책

폼을 전송할 때 다음과 같이 CSRF 방지를 위한 토큰을 함께 전송한다.

POST / remit HTTP/1.1
Host: bank.example
Cookie session=0123456789abcdef
Origin: https://attacker.example/
Referrer: https://attacker.example/
to=attacker
amount=1000000
CSRF_TOKEN=17447cbc879f628bba083b2f6e8368b5

서버는 요청에 포함된 토큰과 세션이 보관된 토큰이 일치하는지를 확인하고, 일치하지 않으면 잘못된 요청으로 간주한다.
공격자는 세션별로 바뀌는 토큰을 알 수 없으므로 세션에 보관된 토큰과 같은 값을 전송할 수 없다.

# Double Submit (이중 전송 쿠키)

랜덤 토큰 값을 가진 쿠키를 발행하고 이 토큰을 사용해 정상적인 요청인지를 확인하는 CSRF대책
정상적인 페이지에서 로그인할 때 세션용 쿠키와 CSRF를 위한 HttpOnly 속성이 부여되지 않은 토큰 값을 갖는 쿠키도 발행한다.
정상 페이지에서 폼을 전송할 때 브라우저의 자바스크립트로 쿠키 내부의 토큰을 가져오고 폼의 요청 헤더와 요청 바디에 삽입한다.
