# 들어가기

```markdown
# 성능 최적화는 어떻게 이루어질까?

웹 성능을 결정하는 요소는 크게 로딩 성능과 렌더링 성능으로 나눌 수 있다.

## 로딩성능

로딩 성능은 서버에 있는 웹 페이지와 웹 페이지에 필요한 기타 리소스를 다운로드할 때의 성능을 말한다.

1. 웹 페이지에 고화질 이미지가 포함되어 있을 때 느린 인터넷 환경에서는 이 이미지가 매우 늦게 표시 될 것
2. HTML이나 자바스크립트, css 파일의 크기가 너무 크면 다운로드 하는데 시간이 오래 걸려 사용자에게 웹 페이지가 느리게 표시될 것

따라서, 로딩 성능을 개선하는 가장 좋은 방법은 다운로드햐해야 하는 리소스 수를 줄이거나 크기를 줄이는 것이다.

## 렌더링 성능

다운로드한 리소스를 가지고 화면을 그릴 때의 성능을 말한다.
```

### 1. 이미지 사이즈 최적화

### 2. 코드분할

### 3. 텍스트 압축

### 4. 병목 코드 최적화

---

# 용어정리

### FCP

페이지가 로드될 때 브라우저가 DOM 콘텐츠의 첫 번째 부분을 렌더링 하는 데 걸리는 시간에 관한 지표

### LCP

페이지가 로드될 때 화면 내에 있는 가장 큰 이미지나 텍스트 요소가 렌더링 되기 까지 걸리는 시간

### TTI

사용자가 페이지와 상호 작용이 가능한 시점까지 걸리는 시간을 측정한 지표

### CLS

페이지 로드 과정에서 발생하는 예기치 못한 레이아웃 이동을 측정한 지표

**레이아웃 이동** : 화면상에서 요소의 위치나 크기가 순간적으로 변하는것

### **OPPORTUNITIES**

페이지를 더욱 빨리 로드하는 데 잠재적으로 도움되는 제안을 나열

### **DIAGNOSTICS**

로드 속도와 직접적인 관계는 없지만 성능과 관련된 기타 정보를 보여줌

---

# 1. 이미지 사이즈 최적화

너무 큰 사이즈의 이미지를 무분별하게 사용하면 네트워크 트래픽이 증가해 서비스 로딩이 오래걸린다.
내용을 보니 실제 이미지 사이즈는 1200px x 1200px 인데, 화면에 그려지는 이미지 사이즈는 120px이다.레티나 디스플레이같은 공간에는 더 많은 픽셀을 그릴 수 있기 때문에 **너비 기준으로 두 배 정도 큰 이미지를 사용하는 것이 적절**하다.

## API를 통해 받아오는 경우에는 어떻게 이미지 사이즈를 조절할까?

### 이미지 CDN

CDN은 물리적 거리의 한계를 극복하기 위해 소비자(사용자)와 가까운 곳에 콘텐츠 서버를 두는 기술을 의미한다. 이미지 CDN은 "사이즈를 줄이거나 포멧을 바꾸는 처리과정을 거치는 기술"이 아니라, **이미지 제공에 특화된 CDN**이라고 봐야한다. 거기에 사이즈를 줄이거나 포멧을 바꾸는 처리과정이 들어가는 것이다.

**이미지 CDN 주소 예시**

```jsx
http://cdn.image.com?src=[img src]&width=240&height=240
```

# 2. 병목코드 최적화

어떤 웹 서비스를 개발했는데 특정 자바스크립트 코드 때문에 서비스가 너무 느리게 다운로드 되거나 느리게 실행되는 경우가 있다.이때 어떤 코드가 무엇 때문에 느린지 몰라서 코드만 보며 한참을 헤매기도 한다. 이처럼 서비스를 느리게 만드는 코드를 병목코드라고 한다.

### 1. CPU 차트, 네트워크, 메인..

CPU 차트는 시간에 따라 CPU가 어떤 작업에 리소스를 사용하고 있는지 비율로 보여준다.

- 자바스크립트 작업은 노란색
- 렌더링/레이아웃 작업은 보라색
- 페인팅 작업은 초록색
- 기타 시스템은 회색으로 표시된다.

그 위에 빨간색 선은 병목이 발생하는 지점을 의미한다. 즉, 특정 작업이 메인 스레드를 오랫동안 잡아 두고 있다는 뜻이다. 네트워크 차트는 CPU 차트 밑에 막대 형태로 표시 된다. 여기는 대략적인 네트워크 상태를 보여준다.

**위쪽 진한 막대** : 우선순위가 높은 네트워크 리소스

**아래쪽** : 우선순위가 낮은

### 2. 네트워크 타임라인

네트워크 패널과 유사하게 서비스 로드 과정에서의 네트워크 요청을 시간 순서에 따라 보여준다.

왼쪽 회색선 : 초기 연결시간

막대의 옅은 회색 선 : 요청을 보낸 시점부터 응답을 기다리는 시점까지의 시간 (노란색)

막대의 짙은 회색 선 : 콘텐츠 다운로드 시간 (노란색)

오른쪽 회색 선 : 해당 요청에 대한 메인 스레드 작업 시간

### 3. Frames, Timings, Main

**Frames 섹션:** 화면의 변화가 있을 떄마다 스크린샷을 찍어 보여준다.

**Timing섹션:** User Timing API를 통해 기록된 정보를 기록한다.

여기 표시된 막대들은 리액트에서 각 컴포넌트의 렌더링 시간을 측정한 것이다.

\*User Timing API 는 리액트 버전 1 이후로 정확성 및 유지 보수 문제로 인해 지원이 종료되었다.

**Main 섹션**: 브라우저의 메인 스레드에서 실행되는 작업을 플레임 차트로 보여준다. 이를 통해 어떤 작업이 오래 걸리는지를 파악할 수 있다.

- 플레임 차트

소프트웨어의 작업(스택)을 손쉽게 추적하기 위해 개발된 계층형 데이터 시각화 기법이다.

X축은 시간의 흐름, Y축은 스택의 깊이를 나타낸다.

### 4. 하단탭

하단에 있는 Summary, Bottom-Up, Call Tree, Event Log 탭에서는 전체 또는 선택된 영역에 대한 상세 내용을 확인할 수 있다.

---

### 개선전

**실행시간** : 무려 1.7초

### 개선후

# Tip

1. 전적인 로딩 시간을 확인 한 후 , 이름을 보고 Main 스레드에서 찾는다.
2. 얼마나 걸렸는지 살펴보고 원인을 분석해 로직을 개선한다.

---

# 3. 코드분할, 지연로딩

### **개선전**

### 개선후

---

# 텍스트 압축

product 환경과 develop환경에는 차이가 있다. production 환경일때는 앞서 실행한 npm run start명령어가 아닌 npm run build를 통해 서비스 코드를 번들링하고 최종적으로 빌드된 파일을 서비스한다. 웹 페이지를 로드할 때는 다양한 리소스를 다운한다. 대표적으로 HTML, CSS, JS와 같은 텍스트 형태의 파일이 있다. 이런 리소스를 다운로드할 때 파일의 크기가 클수록 로딩이 완료되는데 오래걸린다.

기본적으로 HTML, CSS, JS는 텍스트 기반의 파일이다.

# 1장을 읽고 ..

- 로딩속도, 렌더링 속도에 대한 개념이 잡혔다.
- 네트워크 타임라인과 퍼포먼스 탭을 보는 법을 알게됐다.
- 만약 썸네일 이미지가 120\*120이면 무조건 120으로 최적화를 해야한다고 생각했는데 그 이미지 크기의 두배정도 사이즈를 가져가야 안전하게 이미지를 지킬 수 있다는 사실을 알았다.
- 병목 코드의 용어에 대해 알게되었다. 실제 코드를 개선해보니 Timimg 속도가 176.81ms-> 83.42ms 로 개선된것이 신기했다. 블로그 글을 미리 보여줄때 반복문을 빙빙 돌리는것보다 미리 보여줄 숫자만큼 자른 후 정규식으로 특수문자를 없애니 코드 길이 뿐만 아니라 속도까지 개선이 되었다.
- 텍스트 압축과 production, development 환경에 대해서 한번 더 고민해보게 됐다.
